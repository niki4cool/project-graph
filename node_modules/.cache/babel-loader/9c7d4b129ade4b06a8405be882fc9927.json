{"ast":null,"code":"/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nvar EPS = 0.000001;\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n\n  /*******************************************************************\n   * Schema\n   */\n  schema: {\n    mass: {\n      default: 5\n    },\n    radius: {\n      default: 1.3\n    },\n    linearDamping: {\n      default: 0.05\n    },\n    enableSlopes: {\n      default: true\n    },\n    enableJumps: {\n      default: false\n    }\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n  init: function init() {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n    var el = this.el,\n        data = this.data,\n        position = new CANNON.Vec3().copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(new CANNON.Sphere(data.radius), new CANNON.Vec3(0, data.radius, 0));\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n  remove: function remove() {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function beforeStep(t, dt) {\n    if (!dt) return;\n    var el = this.el;\n    var data = this.data;\n    var body = this.body;\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n  step: function () {\n    var velocity = new THREE.Vector3(),\n        normalizedVelocity = new THREE.Vector3(),\n        currentSurfaceNormal = new THREE.Vector3(),\n        groundNormal = new THREE.Vector3();\n    return function (t, dt) {\n      if (!dt) return;\n      var body = this.body,\n          data = this.data,\n          didCollide = false,\n          height,\n          groundHeight = -Infinity,\n          groundBody,\n          contacts = this.system.getContacts();\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) {\n          continue;\n        }\n\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45ยบ) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id ? Math.abs(contact.rj.y + contact.bj.position.y) : Math.abs(contact.ri.y + contact.bi.position.y);\n\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n\n      normalizedVelocity.copy(velocity).normalize();\n\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        } // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45ยบ.\n\n\n        velocity.projectOnPlane(groundNormal);\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }(),\n\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function raycastToGround(groundBody, groundNormal) {\n    var ray,\n        hitNormal,\n        vFrom = this.body.position,\n        vTo = this.body.position.clone();\n    ray = new CANNON.Ray(vFrom, vTo);\n\n    ray._updateDirection(); // TODO - Report bug.\n\n\n    ray.intersectBody(groundBody);\n    if (!ray.hasHit) return groundNormal; // Compare ABS, in case we're projecting against the inside of the face.\n\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});","map":{"version":3,"names":["EPS","module","exports","AFRAME","registerComponent","dependencies","schema","mass","default","radius","linearDamping","enableSlopes","enableJumps","init","system","el","sceneEl","systems","physics","addComponent","data","position","CANNON","Vec3","copy","object3D","getWorldPosition","THREE","Vector3","body","Body","material","getMaterial","fixedRotation","addShape","Sphere","addBody","hasAttribute","console","warn","remove","removeBody","removeComponent","beforeStep","t","dt","velocity","set","getAttribute","step","normalizedVelocity","currentSurfaceNormal","groundNormal","didCollide","height","groundHeight","Infinity","groundBody","contacts","getContacts","Math","min","maxInterval","i","contact","enabled","id","bi","ni","negate","bj","dot","y","projectOnPlane","abs","rj","ri","normalize","raycastToGround","driver","world","add","gravity","scale","setAttribute","ray","hitNormal","vFrom","vTo","clone","Ray","_updateDirection","intersectBody","hasHit","result","hitNormalWorld"],"sources":["X:/Project/graph/node_modules/aframe-extras/src/misc/kinematic-body.js"],"sourcesContent":["/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nconst EPS = 0.000001;\n\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n\n  /*******************************************************************\n   * Schema\n   */\n\n  schema: {\n    mass:           { default: 5 },\n    radius:         { default: 1.3 },\n    linearDamping:  { default: 0.05 },\n    enableSlopes:   { default: true },\n    enableJumps:    { default: false },\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n\n  init: function () {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n\n    const el = this.el,\n        data = this.data,\n        position = (new CANNON.Vec3()).copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(\n      new CANNON.Sphere(data.radius),\n      new CANNON.Vec3(0, data.radius, 0)\n    );\n\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n\n  remove: function () {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function (t, dt) {\n    if (!dt) return;\n\n    const el = this.el;\n    const data = this.data\n    const body = this.body;\n\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n\n  step: (function () {\n    const velocity = new THREE.Vector3(),\n        normalizedVelocity = new THREE.Vector3(),\n        currentSurfaceNormal = new THREE.Vector3(),\n        groundNormal = new THREE.Vector3();\n\n    return function (t, dt) {\n      if (!dt) return;\n\n      let body = this.body,\n          data = this.data,\n          didCollide = false,\n          height, groundHeight = -Infinity,\n          groundBody,\n          contacts = this.system.getContacts();\n\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) { continue; }\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45ยบ) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id\n            ? Math.abs(contact.rj.y + contact.bj.position.y)\n            : Math.abs(contact.ri.y + contact.bi.position.y);\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n\n      normalizedVelocity.copy(velocity).normalize();\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        }\n\n        // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45ยบ.\n        velocity.projectOnPlane(groundNormal);\n\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }()),\n\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function (groundBody, groundNormal) {\n    let ray,\n        hitNormal,\n        vFrom = this.body.position,\n        vTo = this.body.position.clone();\n\n    ray = new CANNON.Ray(vFrom, vTo);\n    ray._updateDirection(); // TODO - Report bug.\n    ray.intersectBody(groundBody);\n\n    if (!ray.hasHit) return groundNormal;\n\n    // Compare ABS, in case we're projecting against the inside of the face.\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}