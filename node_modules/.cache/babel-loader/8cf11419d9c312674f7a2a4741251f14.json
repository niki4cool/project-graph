{"ast":null,"code":"/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\nmodule.exports = THREE.ColladaLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.ColladaLoader.prototype = {\n  constructor: THREE.ColladaLoader,\n  crossOrigin: 'anonymous',\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new THREE.FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.load(url, function (text) {\n      onLoad(scope.parse(text, path));\n    }, onProgress, onError);\n  },\n  setPath: function setPath(value) {\n    this.path = value;\n    return this;\n  },\n  setResourcePath: function setResourcePath(value) {\n    this.resourcePath = value;\n    return this;\n  },\n  options: {\n    set convertUpAxis(value) {\n      console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n    }\n\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  },\n  parse: function parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      var array = [];\n      var childNodes = xml.childNodes;\n\n      for (var i = 0, l = childNodes.length; i < l; i++) {\n        var child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      var library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        var elements = getElementsByTagName(library, nodeName);\n\n        for (var i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (var name in data) {\n        var object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.animations[xml.getAttribute('id')] = data;\n    }\n\n    function parseAnimationSampler(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      var data = {};\n      var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      var parts = target.split('/');\n      var id = parts.shift();\n      var sid = parts.shift(); // check selection syntax\n\n      var arraySyntax = sid.indexOf('(') !== -1;\n      var memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        var indices = sid.split('(');\n        sid = indices.shift();\n\n        for (var i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      var tracks = [];\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n\n      for (var target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          var channel = channels[target];\n          var sampler = samplers[channel.sampler];\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n          var inputSource = sources[inputId];\n          var outputSource = sources[outputId];\n          var animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      var node = library.nodes[channel.id];\n      var object3D = getNode(node.id);\n      var transform = node.transforms[channel.sid];\n      var defaultMatrix = node.matrix.clone().transpose();\n      var time, stride;\n      var i, il, j, jl;\n      var data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              var value = outputSource.array[stride];\n              var index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      var keyframes = prepareAnimationData(data, defaultMatrix);\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      var keyframes = []; // transfer data into a sortable array\n\n      for (var time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (var i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    var position = new THREE.Vector3();\n    var scale = new THREE.Vector3();\n    var quaternion = new THREE.Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        var time = keyframe.time;\n        var value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      var keyframe;\n      var empty = true;\n      var i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      var prev, next;\n\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      var data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      var tracks = [];\n      var name = data.name;\n      var duration = data.end - data.start || -1;\n      var animations = data.animations;\n\n      for (var i = 0, il = animations.length; i < il; i++) {\n        var animationTracks = getAnimation(animations[i]);\n\n        for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new THREE.AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      var data = {\n        sources: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            var id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            var offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      var build = {\n        id: data.id\n      };\n      var geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      var BONE_LIMIT = 4;\n      var build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      var jointSource = data.sources[data.joints.inputs.JOINT];\n      var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      var stride = 0;\n      var i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        var vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          var skinIndex = v[stride + jointOffset];\n          var weightId = v[stride + weightOffset];\n          var skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          var d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new THREE.Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        var name = jointSource.array[i];\n        var boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      var data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      var data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      var sid = xml.getAttribute('sid');\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      var data = {\n        technique: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      var loader;\n      var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      var effect = getEffect(data.url);\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n      var material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new THREE.MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new THREE.MeshLambertMaterial();\n          break;\n\n        default:\n          material = new THREE.MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name;\n\n      function getTexture(textureObject) {\n        var sampler = effect.profile.samplers[textureObject.id];\n        var image = null; // get image\n\n        if (sampler !== undefined) {\n          var surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          var loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            var texture = loader.load(image);\n            var extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              var technique = extra.technique;\n              texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = THREE.RepeatWrapping;\n              texture.wrapT = THREE.RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\n          return null;\n        }\n      }\n\n      var parameters = technique.parameters;\n\n      for (var key in parameters) {\n        var parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      var transparent = parameters['transparent'];\n      var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          var color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = THREE.DoubleSide;\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      var camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new THREE.PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name;\n      return camera;\n    }\n\n    function getCamera(id) {\n      var data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            var array = parseFloats(child.textContent);\n            data.color = new THREE.Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            var f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      var light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new THREE.DirectionalLight();\n          break;\n\n        case 'point':\n          light = new THREE.PointLight();\n          break;\n\n        case 'spot':\n          light = new THREE.SpotLight();\n          break;\n\n        case 'ambient':\n          light = new THREE.AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      var data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (var i = 0; i < mesh.childNodes.length; i++) {\n        var child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      var data = {\n        array: [],\n        stride: 3\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            var accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            var offset = parseInt(child.getAttribute('offset'));\n            var set = parseInt(child.getAttribute('set'));\n            var inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      var build = {};\n\n      for (var i = 0; i < primitives.length; i++) {\n        var primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      var count = 0;\n\n      for (var i = 0, l = primitives.length; i < l; i++) {\n        var primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      var build = {};\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives(primitives);\n\n      for (var type in groupedPrimitives) {\n        var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      var build = {};\n      var position = {\n        array: [],\n        stride: 0\n      };\n      var normal = {\n        array: [],\n        stride: 0\n      };\n      var uv = {\n        array: [],\n        stride: 0\n      };\n      var uv2 = {\n        array: [],\n        stride: 0\n      };\n      var color = {\n        array: [],\n        stride: 0\n      };\n      var skinIndex = {\n        array: [],\n        stride: 4\n      };\n      var skinWeight = {\n        array: [],\n        stride: 4\n      };\n      var geometry = new THREE.BufferGeometry();\n      var materialKeys = [];\n      var start = 0;\n\n      for (var p = 0; p < primitives.length; p++) {\n        var primitive = primitives[p];\n        var inputs = primitive.inputs; // groups\n\n        var count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (var g = 0; g < primitive.count; g++) {\n              var vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (var name in inputs) {\n          var input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (var key in vertices) {\n                var id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      var count = (position.array.length - prevLength) / position.stride;\n\n                      for (var i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.addAttribute('uv2', new THREE.Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.addAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n\n      function pushVector(i) {\n        var index = indices[i + offset] * sourceStride;\n        var length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        var index = 0;\n\n        for (var i = 0, l = vcount.length; i < l; i++) {\n          var count = vcount[i];\n\n          if (count === 4) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (var k = 1, kl = count - 2; k <= kl; k++) {\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (var i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      var data;\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml, data) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new THREE.Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            var max = child.getElementsByTagName('max')[0];\n            var min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      var data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      var data = {\n        type: xml.nodeName\n      };\n      var array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new THREE.Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray(array);\n          data.angle = THREE.Math.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      var data = {\n        bindJointAxis: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      var data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      var visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      var kinematicsModel = getKinematicsModel(kinematicsModelId);\n      var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      var visualScene = getVisualScene(visualSceneId);\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n\n      for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n        var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transfrom element\n          var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        var visualElementName = visualElement.getAttribute('name');\n        var joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      var m0 = new THREE.Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function getJointValue(jointIndex) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\n          }\n        },\n        setJointValue: function setJointValue(jointIndex, value) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            var joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (var i = 0; i < transforms.length; i++) {\n                var transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, THREE.Math.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      var transforms = [];\n      var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            var matrix = new THREE.Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            var vector = new THREE.Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var vector = new THREE.Vector3().fromArray(array);\n            var angle = THREE.Math.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (var i = 0; i < elements.length; i++) {\n        var element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    var matrix = new THREE.Matrix4();\n    var vector = new THREE.Vector3();\n\n    function parseNode(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new THREE.Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            var array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var angle = THREE.Math.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      var data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            var instances = child.getElementsByTagName('instance_material');\n\n            for (var j = 0; j < instances.length; j++) {\n              var instance = instances[j];\n              var symbol = instance.getAttribute('symbol');\n              var target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      var boneData = [];\n      var sortedBoneData = [];\n      var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        var skeleton = skeletons[i];\n        var root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          var visualScene = library.visualScenes[skeleton];\n          var children = visualScene.children;\n\n          for (var j = 0; j < children.length; j++) {\n            var child = children[j];\n\n            if (child.type === 'JOINT') {\n              var root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      var bones = [];\n      var boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new THREE.Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          var boneInverse; // retrieve the boneInverse from the controller data\n\n          for (var i = 0; i < joints.length; i++) {\n            var joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new THREE.Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      var objects = [];\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes; // nodes\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (var i = 0, l = instanceCameras.length; i < l; i++) {\n        var instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (var i = 0, l = instanceControllers.length; i < l; i++) {\n        var instance = instanceControllers[i];\n        var controller = getController(instance.id);\n        var geometries = getGeometry(controller.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n        var skeleton = buildSkeleton(skeletons, joints);\n\n        for (var j = 0, jl = newObjects.length; j < jl; j++) {\n          var object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (var i = 0, l = instanceLights.length; i < l; i++) {\n        var instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (var i = 0, l = instanceGeometries.length; i < l; i++) {\n        var instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry(instance.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n\n        for (var j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (var i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      var object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();\n\n        for (var i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      if (object.name === '') {\n        object.name = type === 'JOINT' ? data.sid : data.name;\n      }\n\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    var fallbackMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      var materials = [];\n\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      var objects = [];\n\n      for (var type in geometries) {\n        var geometry = geometries[type];\n        var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new THREE.LineBasicMaterial());\n          } else {\n            materials.push(new THREE.MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        var skinning = geometry.data.attributes.skinIndex !== undefined;\n\n        if (skinning) {\n          for (var i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        } // choose between a single or multi materials (material array)\n\n\n        var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        var object;\n\n        switch (type) {\n          case 'lines':\n            object = new THREE.LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new THREE.Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new THREE.SkinnedMesh(geometry.data, material);\n            } else {\n              object = new THREE.Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      var elements = getElementsByTagName(xml, 'node');\n\n      for (var i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      var group = new THREE.Group();\n      group.name = data.name;\n      var children = data.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      var clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          var tracks = [];\n\n          for (var id in library.animations) {\n            var animationTracks = getAnimation(id);\n\n            for (var i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new THREE.AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (var id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new THREE.Scene()\n      };\n    }\n\n    var xml = new DOMParser().parseFromString(text, 'application/xml');\n    var collada = getElementsByTagName(xml, 'COLLADA')[0]; // metadata\n\n    var version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    var textureLoader = new THREE.TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var tgaLoader;\n\n    if (THREE.TGALoader) {\n      tgaLoader = new THREE.TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0; //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      animations: animations,\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n};","map":{"version":3,"names":["module","exports","THREE","ColladaLoader","manager","undefined","DefaultLoadingManager","prototype","constructor","crossOrigin","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","text","parse","value","setResourcePath","resourcePath","options","convertUpAxis","console","warn","setCrossOrigin","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","index","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","Vector3","scale","quaternion","Quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","VectorKeyframeTrack","QuaternionKeyframeTrack","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","AnimationClip","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","Matrix4","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechnique","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","MeshPhongMaterial","MeshLambertMaterial","MeshBasicMaterial","getTexture","textureObject","surface","texture","wrapS","wrapU","RepeatWrapping","ClampToEdgeWrapping","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","double_sided","side","DoubleSide","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","PerspectiveCamera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","OrthographicCamera","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","Color","falloffAngle","f","distance","Math","sqrt","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","BufferGeometry","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","addAttribute","Float32BufferAttribute","pushVector","sourceStride","sourceArray","c","k","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","setAttribute","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","error","bone","processed","bones","boneInverses","Skeleton","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","Bone","Group","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","LineBasicMaterial","skinning","attributes","LineSegments","Line","SkinnedMesh","Mesh","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","scene","Scene","DOMParser","parseFromString","version","asset","TextureLoader","TGALoader","setFromEuler","Euler","PI","multiplyScalar"],"sources":["X:/Project/back/node_modules/aframe-extras/lib/ColladaLoader.js"],"sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nmodule.exports = THREE.ColladaLoader = function ( manager ) {\n\n  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.ColladaLoader.prototype = {\n\n  constructor: THREE.ColladaLoader,\n\n  crossOrigin: 'anonymous',\n\n  load: function ( url, onLoad, onProgress, onError ) {\n\n    var scope = this;\n\n    var path = ( scope.path === undefined ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n    var loader = new THREE.FileLoader( scope.manager );\n    loader.setPath( scope.path );\n    loader.load( url, function ( text ) {\n\n      onLoad( scope.parse( text, path ) );\n\n    }, onProgress, onError );\n\n  },\n\n  setPath: function ( value ) {\n\n    this.path = value;\n    return this;\n\n  },\n\n  setResourcePath: function ( value ) {\n\n    this.resourcePath = value;\n    return this;\n\n  },\n\n  options: {\n\n    set convertUpAxis( value ) {\n\n      console.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\n    }\n\n  },\n\n  setCrossOrigin: function ( value ) {\n\n    this.crossOrigin = value;\n    return this;\n\n  },\n\n  parse: function ( text, path ) {\n\n    function getElementsByTagName( xml, name ) {\n\n      // Non recursive xml.getElementsByTagName() ...\n\n      var array = [];\n      var childNodes = xml.childNodes;\n\n      for ( var i = 0, l = childNodes.length; i < l; i ++ ) {\n\n        var child = childNodes[ i ];\n\n        if ( child.nodeName === name ) {\n\n          array.push( child );\n\n        }\n\n      }\n\n      return array;\n\n    }\n\n    function parseStrings( text ) {\n\n      if ( text.length === 0 ) return [];\n\n      var parts = text.trim().split( /\\s+/ );\n      var array = new Array( parts.length );\n\n      for ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n        array[ i ] = parts[ i ];\n\n      }\n\n      return array;\n\n    }\n\n    function parseFloats( text ) {\n\n      if ( text.length === 0 ) return [];\n\n      var parts = text.trim().split( /\\s+/ );\n      var array = new Array( parts.length );\n\n      for ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n        array[ i ] = parseFloat( parts[ i ] );\n\n      }\n\n      return array;\n\n    }\n\n    function parseInts( text ) {\n\n      if ( text.length === 0 ) return [];\n\n      var parts = text.trim().split( /\\s+/ );\n      var array = new Array( parts.length );\n\n      for ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n        array[ i ] = parseInt( parts[ i ] );\n\n      }\n\n      return array;\n\n    }\n\n    function parseId( text ) {\n\n      return text.substring( 1 );\n\n    }\n\n    function generateId() {\n\n      return 'three_default_' + ( count ++ );\n\n    }\n\n    function isEmpty( object ) {\n\n      return Object.keys( object ).length === 0;\n\n    }\n\n    // asset\n\n    function parseAsset( xml ) {\n\n      return {\n        unit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n        upAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n      };\n\n    }\n\n    function parseAssetUnit( xml ) {\n\n      if ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n        return parseFloat( xml.getAttribute( 'meter' ) );\n\n      } else {\n\n        return 1; // default 1 meter\n\n      }\n\n    }\n\n    function parseAssetUpAxis( xml ) {\n\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n\n    }\n\n    // library\n\n    function parseLibrary( xml, libraryName, nodeName, parser ) {\n\n      var library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n      if ( library !== undefined ) {\n\n        var elements = getElementsByTagName( library, nodeName );\n\n        for ( var i = 0; i < elements.length; i ++ ) {\n\n          parser( elements[ i ] );\n\n        }\n\n      }\n\n    }\n\n    function buildLibrary( data, builder ) {\n\n      for ( var name in data ) {\n\n        var object = data[ name ];\n        object.build = builder( data[ name ] );\n\n      }\n\n    }\n\n    // get\n\n    function getBuild( data, builder ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      data.build = builder( data );\n\n      return data.build;\n\n    }\n\n    // animation\n\n    function parseAnimation( xml ) {\n\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        var id;\n\n        switch ( child.nodeName ) {\n\n          case 'source':\n            id = child.getAttribute( 'id' );\n            data.sources[ id ] = parseSource( child );\n            break;\n\n          case 'sampler':\n            id = child.getAttribute( 'id' );\n            data.samplers[ id ] = parseAnimationSampler( child );\n            break;\n\n          case 'channel':\n            id = child.getAttribute( 'target' );\n            data.channels[ id ] = parseAnimationChannel( child );\n            break;\n\n          default:\n            console.log( child );\n\n        }\n\n      }\n\n      library.animations[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseAnimationSampler( xml ) {\n\n      var data = {\n        inputs: {},\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var id = parseId( child.getAttribute( 'source' ) );\n            var semantic = child.getAttribute( 'semantic' );\n            data.inputs[ semantic ] = id;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseAnimationChannel( xml ) {\n\n      var data = {};\n\n      var target = xml.getAttribute( 'target' );\n\n      // parsing SID Addressing Syntax\n\n      var parts = target.split( '/' );\n\n      var id = parts.shift();\n      var sid = parts.shift();\n\n      // check selection syntax\n\n      var arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n      var memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n      if ( memberSyntax ) {\n\n        //  member selection access\n\n        parts = sid.split( '.' );\n        sid = parts.shift();\n        data.member = parts.shift();\n\n      } else if ( arraySyntax ) {\n\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n        var indices = sid.split( '(' );\n        sid = indices.shift();\n\n        for ( var i = 0; i < indices.length; i ++ ) {\n\n          indices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n        }\n\n        data.indices = indices;\n\n      }\n\n      data.id = id;\n      data.sid = sid;\n\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n\n      data.sampler = parseId( xml.getAttribute( 'source' ) );\n\n      return data;\n\n    }\n\n    function buildAnimation( data ) {\n\n      var tracks = [];\n\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n\n      for ( var target in channels ) {\n\n        if ( channels.hasOwnProperty( target ) ) {\n\n          var channel = channels[ target ];\n          var sampler = samplers[ channel.sampler ];\n\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n\n          var inputSource = sources[ inputId ];\n          var outputSource = sources[ outputId ];\n\n          var animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n          createKeyframeTracks( animation, tracks );\n\n        }\n\n      }\n\n      return tracks;\n\n    }\n\n    function getAnimation( id ) {\n\n      return getBuild( library.animations[ id ], buildAnimation );\n\n    }\n\n    function buildAnimationChannel( channel, inputSource, outputSource ) {\n\n      var node = library.nodes[ channel.id ];\n      var object3D = getNode( node.id );\n\n      var transform = node.transforms[ channel.sid ];\n      var defaultMatrix = node.matrix.clone().transpose();\n\n      var time, stride;\n      var i, il, j, jl;\n\n      var data = {};\n\n      // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch ( transform ) {\n\n        case 'matrix':\n\n          for ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n            time = inputSource.array[ i ];\n            stride = i * outputSource.stride;\n\n            if ( data[ time ] === undefined ) data[ time ] = {};\n\n            if ( channel.arraySyntax === true ) {\n\n              var value = outputSource.array[ stride ];\n              var index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n              data[ time ][ index ] = value;\n\n            } else {\n\n              for ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n                data[ time ][ j ] = outputSource.array[ stride + j ];\n\n              }\n\n            }\n\n          }\n\n          break;\n\n        case 'translate':\n          console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n          break;\n\n        case 'rotate':\n          console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n          break;\n\n        case 'scale':\n          console.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n          break;\n\n      }\n\n      var keyframes = prepareAnimationData( data, defaultMatrix );\n\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n\n      return animation;\n\n    }\n\n    function prepareAnimationData( data, defaultMatrix ) {\n\n      var keyframes = [];\n\n      // transfer data into a sortable array\n\n      for ( var time in data ) {\n\n        keyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n      }\n\n      // ensure keyframes are sorted by time\n\n      keyframes.sort( ascending );\n\n      // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for ( var i = 0; i < 16; i ++ ) {\n\n        transformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n      }\n\n      return keyframes;\n\n      // array sort function\n\n      function ascending( a, b ) {\n\n        return a.time - b.time;\n\n      }\n\n    }\n\n    var position = new THREE.Vector3();\n    var scale = new THREE.Vector3();\n    var quaternion = new THREE.Quaternion();\n\n    function createKeyframeTracks( animation, tracks ) {\n\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n\n      for ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n        var keyframe = keyframes[ i ];\n\n        var time = keyframe.time;\n        var value = keyframe.value;\n\n        matrix.fromArray( value ).transpose();\n        matrix.decompose( position, quaternion, scale );\n\n        times.push( time );\n        positionData.push( position.x, position.y, position.z );\n        quaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n        scaleData.push( scale.x, scale.y, scale.z );\n\n      }\n\n      if ( positionData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.position', times, positionData ) );\n      if ( quaternionData.length > 0 ) tracks.push( new THREE.QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n      if ( scaleData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n      return tracks;\n\n    }\n\n    function transformAnimationData( keyframes, property, defaultValue ) {\n\n      var keyframe;\n\n      var empty = true;\n      var i, l;\n\n      // check, if values of a property are missing in our keyframes\n\n      for ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n        keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] === undefined ) {\n\n          keyframe.value[ property ] = null; // mark as missing\n\n        } else {\n\n          empty = false;\n\n        }\n\n      }\n\n      if ( empty === true ) {\n\n        // no values at all, so we set a default value\n\n        for ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n          keyframe = keyframes[ i ];\n\n          keyframe.value[ property ] = defaultValue;\n\n        }\n\n      } else {\n\n        // filling gaps\n\n        createMissingKeyframes( keyframes, property );\n\n      }\n\n    }\n\n    function createMissingKeyframes( keyframes, property ) {\n\n      var prev, next;\n\n      for ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n        var keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] === null ) {\n\n          prev = getPrev( keyframes, i, property );\n          next = getNext( keyframes, i, property );\n\n          if ( prev === null ) {\n\n            keyframe.value[ property ] = next.value[ property ];\n            continue;\n\n          }\n\n          if ( next === null ) {\n\n            keyframe.value[ property ] = prev.value[ property ];\n            continue;\n\n          }\n\n          interpolate( keyframe, prev, next, property );\n\n        }\n\n      }\n\n    }\n\n    function getPrev( keyframes, i, property ) {\n\n      while ( i >= 0 ) {\n\n        var keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] !== null ) return keyframe;\n\n        i --;\n\n      }\n\n      return null;\n\n    }\n\n    function getNext( keyframes, i, property ) {\n\n      while ( i < keyframes.length ) {\n\n        var keyframe = keyframes[ i ];\n\n        if ( keyframe.value[ property ] !== null ) return keyframe;\n\n        i ++;\n\n      }\n\n      return null;\n\n    }\n\n    function interpolate( key, prev, next, property ) {\n\n      if ( ( next.time - prev.time ) === 0 ) {\n\n        key.value[ property ] = prev.value[ property ];\n        return;\n\n      }\n\n      key.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n    }\n\n    // animation clips\n\n    function parseAnimationClip( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'id' ) || 'default',\n        start: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n        end: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n        animations: []\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'instance_animation':\n            data.animations.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n        }\n\n      }\n\n      library.clips[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildAnimationClip( data ) {\n\n      var tracks = [];\n\n      var name = data.name;\n      var duration = ( data.end - data.start ) || - 1;\n      var animations = data.animations;\n\n      for ( var i = 0, il = animations.length; i < il; i ++ ) {\n\n        var animationTracks = getAnimation( animations[ i ] );\n\n        for ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n          tracks.push( animationTracks[ j ] );\n\n        }\n\n      }\n\n      return new THREE.AnimationClip( name, duration, tracks );\n\n    }\n\n    function getAnimationClip( id ) {\n\n      return getBuild( library.clips[ id ], buildAnimationClip );\n\n    }\n\n    // controller\n\n    function parseController( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId( child.getAttribute( 'source' ) );\n            data.skin = parseSkin( child );\n            break;\n\n          case 'morph':\n            data.id = parseId( child.getAttribute( 'source' ) );\n            console.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n            break;\n\n        }\n\n      }\n\n      library.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseSkin( xml ) {\n\n      var data = {\n        sources: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats( child.textContent );\n            break;\n\n          case 'source':\n            var id = child.getAttribute( 'id' );\n            data.sources[ id ] = parseSource( child );\n            break;\n\n          case 'joints':\n            data.joints = parseJoints( child );\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseJoints( xml ) {\n\n      var data = {\n        inputs: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var semantic = child.getAttribute( 'semantic' );\n            var id = parseId( child.getAttribute( 'source' ) );\n            data.inputs[ semantic ] = id;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseVertexWeights( xml ) {\n\n      var data = {\n        inputs: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var semantic = child.getAttribute( 'semantic' );\n            var id = parseId( child.getAttribute( 'source' ) );\n            var offset = parseInt( child.getAttribute( 'offset' ) );\n            data.inputs[ semantic ] = { id: id, offset: offset };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts( child.textContent );\n            break;\n\n          case 'v':\n            data.v = parseInts( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildController( data ) {\n\n      var build = {\n        id: data.id\n      };\n\n      var geometry = library.geometries[ build.id ];\n\n      if ( data.skin !== undefined ) {\n\n        build.skin = buildSkin( data.skin );\n\n        // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n\n      }\n\n      return build;\n\n    }\n\n    function buildSkin( data ) {\n\n      var BONE_LIMIT = 4;\n\n      var build = {\n        joints: [], // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n      var jointSource = data.sources[ data.joints.inputs.JOINT ];\n      var inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n      var weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n      var stride = 0;\n\n      var i, j, l;\n\n      // procces skin data for each vertex\n\n      for ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n        var jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n        var vertexSkinData = [];\n\n        for ( j = 0; j < jointCount; j ++ ) {\n\n          var skinIndex = v[ stride + jointOffset ];\n          var weightId = v[ stride + weightOffset ];\n          var skinWeight = weights[ weightId ];\n\n          vertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n          stride += 2;\n\n        }\n\n        // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort( descending );\n\n        // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n          var d = vertexSkinData[ j ];\n\n          if ( d !== undefined ) {\n\n            build.indices.array.push( d.index );\n            build.weights.array.push( d.weight );\n\n          } else {\n\n            build.indices.array.push( 0 );\n            build.weights.array.push( 0 );\n\n          }\n\n        }\n\n      }\n\n      // setup bind matrix\n\n      if ( data.bindShapeMatrix ) {\n\n        build.bindMatrix = new THREE.Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n      } else {\n\n        build.bindMatrix = new THREE.Matrix4().identity();\n\n      }\n\n      // process bones and inverse bind matrix data\n\n      for ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n        var name = jointSource.array[ i ];\n        var boneInverse = new THREE.Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n        build.joints.push( { name: name, boneInverse: boneInverse } );\n\n      }\n\n      return build;\n\n      // array sort function\n\n      function descending( a, b ) {\n\n        return b.weight - a.weight;\n\n      }\n\n    }\n\n    function getController( id ) {\n\n      return getBuild( library.controllers[ id ], buildController );\n\n    }\n\n    // image\n\n    function parseImage( xml ) {\n\n      var data = {\n        init_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n      };\n\n      library.images[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildImage( data ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      return data.init_from;\n\n    }\n\n    function getImage( id ) {\n\n      var data = library.images[ id ];\n\n      if ( data !== undefined ) {\n\n        return getBuild( data, buildImage );\n\n      }\n\n      console.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n      return null;\n\n    }\n\n    // effect\n\n    function parseEffect( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON( child );\n            break;\n\n        }\n\n      }\n\n      library.effects[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseEffectProfileCOMMON( xml ) {\n\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'newparam':\n            parseEffectNewparam( child, data );\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique( child );\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectNewparam( xml, data ) {\n\n      var sid = xml.getAttribute( 'sid' );\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'surface':\n            data.surfaces[ sid ] = parseEffectSurface( child );\n            break;\n\n          case 'sampler2D':\n            data.samplers[ sid ] = parseEffectSampler( child );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseEffectSurface( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectSampler( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'source':\n            data.source = child.textContent;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameters( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[ child.nodeName ] = parseEffectParameter( child );\n            break;\n          case 'transparent':\n            data[ child.nodeName ] = {\n              opaque: child.getAttribute( 'opaque' ),\n              data: parseEffectParameter( child )\n            };\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameter( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'color':\n            data[ child.nodeName ] = parseFloats( child.textContent );\n            break;\n\n          case 'float':\n            data[ child.nodeName ] = parseFloat( child.textContent );\n            break;\n\n          case 'texture':\n            data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameterTexture( xml ) {\n\n      var data = {\n        technique: {}\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'extra':\n            parseEffectParameterTextureExtra( child, data );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectParameterTextureExtra( xml, data ) {\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique( child, data );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[ child.nodeName ] = parseFloat( child.textContent );\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n\n            if ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n              data.technique[ child.nodeName ] = 1;\n\n            } else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n              data.technique[ child.nodeName ] = 0;\n\n            } else {\n\n              data.technique[ child.nodeName ] = parseInt( child.textContent );\n\n            }\n\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseEffectExtra( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique':\n            data.technique = parseEffectExtraTechnique( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseEffectExtraTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'double_sided':\n            data[ child.nodeName ] = parseInt( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildEffect( data ) {\n\n      return data;\n\n    }\n\n    function getEffect( id ) {\n\n      return getBuild( library.effects[ id ], buildEffect );\n\n    }\n\n    // material\n\n    function parseMaterial( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' )\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'instance_effect':\n            data.url = parseId( child.getAttribute( 'url' ) );\n            break;\n\n        }\n\n      }\n\n      library.materials[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function getTextureLoader( image ) {\n\n      var loader;\n\n      var extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n      extension = extension.toLowerCase();\n\n      switch ( extension ) {\n\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n\n      }\n\n      return loader;\n\n    }\n\n    function buildMaterial( data ) {\n\n      var effect = getEffect( data.url );\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n\n      var material;\n\n      switch ( technique.type ) {\n\n        case 'phong':\n        case 'blinn':\n          material = new THREE.MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new THREE.MeshLambertMaterial();\n          break;\n\n        default:\n          material = new THREE.MeshBasicMaterial();\n          break;\n\n      }\n\n      material.name = data.name;\n\n      function getTexture( textureObject ) {\n\n        var sampler = effect.profile.samplers[ textureObject.id ];\n        var image = null;\n\n        // get image\n\n        if ( sampler !== undefined ) {\n\n          var surface = effect.profile.surfaces[ sampler.source ];\n          image = getImage( surface.init_from );\n\n        } else {\n\n          console.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n          image = getImage( textureObject.id );\n\n        }\n\n        // create texture if image is avaiable\n\n        if ( image !== null ) {\n\n          var loader = getTextureLoader( image );\n\n          if ( loader !== undefined ) {\n\n            var texture = loader.load( image );\n\n            var extra = textureObject.extra;\n\n            if ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n              var technique = extra.technique;\n\n              texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n              texture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n              texture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n            } else {\n\n              texture.wrapS = THREE.RepeatWrapping;\n              texture.wrapT = THREE.RepeatWrapping;\n\n            }\n\n            return texture;\n\n          } else {\n\n            console.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n            return null;\n\n          }\n\n        } else {\n\n          console.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n          return null;\n\n        }\n\n      }\n\n      var parameters = technique.parameters;\n\n      for ( var key in parameters ) {\n\n        var parameter = parameters[ key ];\n\n        switch ( key ) {\n\n          case 'diffuse':\n            if ( parameter.color ) material.color.fromArray( parameter.color );\n            if ( parameter.texture ) material.map = getTexture( parameter.texture );\n            break;\n          case 'specular':\n            if ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n            if ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n            break;\n          case 'bump':\n            if ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n            break;\n          case 'ambient':\n            if ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n            break;\n          case 'shininess':\n            if ( parameter.float && material.shininess ) material.shininess = parameter.float;\n            break;\n          case 'emission':\n            if ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n            if ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n            break;\n\n        }\n\n      }\n\n      //\n\n      var transparent = parameters[ 'transparent' ];\n      var transparency = parameters[ 'transparency' ];\n\n      // <transparency> does not exist but <transparent>\n\n      if ( transparency === undefined && transparent ) {\n\n        transparency = {\n          float: 1\n        };\n\n      }\n\n      // <transparent> does not exist but <transparency>\n\n      if ( transparent === undefined && transparency ) {\n\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [ 1, 1, 1, 1 ]\n          } };\n\n      }\n\n      if ( transparent && transparency ) {\n\n        // handle case if a texture exists but no color\n\n        if ( transparent.data.texture ) {\n\n          // we do not set an alpha map (see #13792)\n\n          material.transparent = true;\n\n        } else {\n\n          var color = transparent.data.color;\n\n          switch ( transparent.opaque ) {\n\n            case 'A_ONE':\n              material.opacity = color[ 3 ] * transparency.float;\n              break;\n            case 'RGB_ZERO':\n              material.opacity = 1 - ( color[ 0 ] * transparency.float );\n              break;\n            case 'A_ZERO':\n              material.opacity = 1 - ( color[ 3 ] * transparency.float );\n              break;\n            case 'RGB_ONE':\n              material.opacity = color[ 0 ] * transparency.float;\n              break;\n            default:\n              console.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n          }\n\n          if ( material.opacity < 1 ) material.transparent = true;\n\n        }\n\n      }\n\n      //\n\n      if ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n        material.side = THREE.DoubleSide;\n\n      }\n\n      return material;\n\n    }\n\n    function getMaterial( id ) {\n\n      return getBuild( library.materials[ id ], buildMaterial );\n\n    }\n\n    // camera\n\n    function parseCamera( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' )\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'optics':\n            data.optics = parseCameraOptics( child );\n            break;\n\n        }\n\n      }\n\n      library.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseCameraOptics( xml ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            return parseCameraTechnique( child );\n\n        }\n\n      }\n\n      return {};\n\n    }\n\n    function parseCameraTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'perspective':\n          case 'orthographic':\n\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters( child );\n\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseCameraParameters( xml ) {\n\n      var data = {};\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[ child.nodeName ] = parseFloat( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildCamera( data ) {\n\n      var camera;\n\n      switch ( data.optics.technique ) {\n\n        case 'perspective':\n          camera = new THREE.PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n\n          xmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n          ymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n          xmag *= 0.5;\n          ymag *= 0.5;\n\n          camera = new THREE.OrthographicCamera(\n            - xmag, xmag, ymag, - ymag, // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar\n          );\n          break;\n\n        default:\n          camera = new THREE.PerspectiveCamera();\n          break;\n\n      }\n\n      camera.name = data.name;\n\n      return camera;\n\n    }\n\n    function getCamera( id ) {\n\n      var data = library.cameras[ id ];\n\n      if ( data !== undefined ) {\n\n        return getBuild( data, buildCamera );\n\n      }\n\n      console.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n      return null;\n\n    }\n\n    // light\n\n    function parseLight( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            data = parseLightTechnique( child );\n            break;\n\n        }\n\n      }\n\n      library.lights[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseLightTechnique( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters( child );\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseLightParameters( xml ) {\n\n      var data = {};\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'color':\n            var array = parseFloats( child.textContent );\n            data.color = new THREE.Color().fromArray( array );\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat( child.textContent );\n            break;\n\n          case 'quadratic_attenuation':\n            var f = parseFloat( child.textContent );\n            data.distance = f ? Math.sqrt( 1 / f ) : 0;\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildLight( data ) {\n\n      var light;\n\n      switch ( data.technique ) {\n\n        case 'directional':\n          light = new THREE.DirectionalLight();\n          break;\n\n        case 'point':\n          light = new THREE.PointLight();\n          break;\n\n        case 'spot':\n          light = new THREE.SpotLight();\n          break;\n\n        case 'ambient':\n          light = new THREE.AmbientLight();\n          break;\n\n      }\n\n      if ( data.parameters.color ) light.color.copy( data.parameters.color );\n      if ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n      return light;\n\n    }\n\n    function getLight( id ) {\n\n      var data = library.lights[ id ];\n\n      if ( data !== undefined ) {\n\n        return getBuild( data, buildLight );\n\n      }\n\n      console.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n      return null;\n\n    }\n\n    // geometry\n\n    function parseGeometry( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n\n      var mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n      // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n      if ( mesh === undefined ) return;\n\n      for ( var i = 0; i < mesh.childNodes.length; i ++ ) {\n\n        var child = mesh.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        var id = child.getAttribute( 'id' );\n\n        switch ( child.nodeName ) {\n\n          case 'source':\n            data.sources[ id ] = parseSource( child );\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices( child );\n            break;\n\n          case 'polygons':\n            console.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push( parseGeometryPrimitive( child ) );\n            break;\n\n          default:\n            console.log( child );\n\n        }\n\n      }\n\n      library.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parseSource( xml ) {\n\n      var data = {\n        array: [],\n        stride: 3\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'float_array':\n            data.array = parseFloats( child.textContent );\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings( child.textContent );\n            break;\n\n          case 'technique_common':\n            var accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n            if ( accessor !== undefined ) {\n\n              data.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n            }\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseGeometryVertices( xml ) {\n\n      var data = {};\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        data[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n      }\n\n      return data;\n\n    }\n\n    function parseGeometryPrimitive( xml ) {\n\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute( 'material' ),\n        count: parseInt( xml.getAttribute( 'count' ) ),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'input':\n            var id = parseId( child.getAttribute( 'source' ) );\n            var semantic = child.getAttribute( 'semantic' );\n            var offset = parseInt( child.getAttribute( 'offset' ) );\n            var set = parseInt( child.getAttribute( 'set' ) );\n            var inputname = ( set > 0 ? semantic + set : semantic );\n            primitive.inputs[ inputname ] = { id: id, offset: offset };\n            primitive.stride = Math.max( primitive.stride, offset + 1 );\n            if ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts( child.textContent );\n            break;\n\n          case 'p':\n            primitive.p = parseInts( child.textContent );\n            break;\n\n        }\n\n      }\n\n      return primitive;\n\n    }\n\n    function groupPrimitives( primitives ) {\n\n      var build = {};\n\n      for ( var i = 0; i < primitives.length; i ++ ) {\n\n        var primitive = primitives[ i ];\n\n        if ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n        build[ primitive.type ].push( primitive );\n\n      }\n\n      return build;\n\n    }\n\n    function checkUVCoordinates( primitives ) {\n\n      var count = 0;\n\n      for ( var i = 0, l = primitives.length; i < l; i ++ ) {\n\n        var primitive = primitives[ i ];\n\n        if ( primitive.hasUV === true ) {\n\n          count ++;\n\n        }\n\n      }\n\n      if ( count > 0 && count < primitives.length ) {\n\n        primitives.uvsNeedsFix = true;\n\n      }\n\n    }\n\n    function buildGeometry( data ) {\n\n      var build = {};\n\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n\n      if ( primitives.length === 0 ) return {};\n\n      // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives( primitives );\n\n      for ( var type in groupedPrimitives ) {\n\n        var primitiveType = groupedPrimitives[ type ];\n\n        // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates( primitiveType );\n\n        // third, create a buffer geometry for each type of primitives\n\n        build[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n      }\n\n      return build;\n\n    }\n\n    function buildGeometryType( primitives, sources, vertices ) {\n\n      var build = {};\n\n      var position = { array: [], stride: 0 };\n      var normal = { array: [], stride: 0 };\n      var uv = { array: [], stride: 0 };\n      var uv2 = { array: [], stride: 0 };\n      var color = { array: [], stride: 0 };\n\n      var skinIndex = { array: [], stride: 4 };\n      var skinWeight = { array: [], stride: 4 };\n\n      var geometry = new THREE.BufferGeometry();\n\n      var materialKeys = [];\n\n      var start = 0;\n\n      for ( var p = 0; p < primitives.length; p ++ ) {\n\n        var primitive = primitives[ p ];\n        var inputs = primitive.inputs;\n\n        // groups\n\n        var count = 0;\n\n        switch ( primitive.type ) {\n\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n\n            for ( var g = 0; g < primitive.count; g ++ ) {\n\n              var vc = primitive.vcount[ g ];\n\n              switch ( vc ) {\n\n                case 3:\n                  count += 3; // single triangle\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n                  break;\n\n                default:\n                  count += ( vc - 2 ) * 3; // polylist with more than four vertices\n                  break;\n\n              }\n\n            }\n\n            break;\n\n          default:\n            console.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n        }\n\n        geometry.addGroup( start, count, p );\n        start += count;\n\n        // material\n\n        if ( primitive.material ) {\n\n          materialKeys.push( primitive.material );\n\n        }\n\n        // geometry data\n\n        for ( var name in inputs ) {\n\n          var input = inputs[ name ];\n\n          switch ( name ) {\n\n            case 'VERTEX':\n              for ( var key in vertices ) {\n\n                var id = vertices[ key ];\n\n                switch ( key ) {\n\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData( primitive, sources[ id ], input.offset, position.array );\n                    position.stride = sources[ id ].stride;\n\n                    if ( sources.skinWeights && sources.skinIndices ) {\n\n                      buildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n                      buildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n                    }\n\n                    // see #3803\n\n                    if ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n                      var count = ( position.array.length - prevLength ) / position.stride;\n\n                      for ( var i = 0; i < count; i ++ ) {\n\n                        // fill missing uv coordinates\n\n                        uv.array.push( 0, 0 );\n\n                      }\n\n                    }\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n                    normal.stride = sources[ id ].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData( primitive, sources[ id ], input.offset, color.array );\n                    color.stride = sources[ id ].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n                    uv.stride = sources[ id ].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n                    uv.stride = sources[ id ].stride;\n                    break;\n\n                  default:\n                    console.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n                }\n\n              }\n              break;\n\n            case 'NORMAL':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n              normal.stride = sources[ input.id ].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n              color.stride = sources[ input.id ].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n              uv.stride = sources[ input.id ].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n              uv2.stride = sources[ input.id ].stride;\n              break;\n\n          }\n\n        }\n\n      }\n\n      // build geometry\n\n      if ( position.array.length > 0 ) geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( position.array, position.stride ) );\n      if ( normal.array.length > 0 ) geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normal.array, normal.stride ) );\n      if ( color.array.length > 0 ) geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( color.array, color.stride ) );\n      if ( uv.array.length > 0 ) geometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( uv.array, uv.stride ) );\n      if ( uv2.array.length > 0 ) geometry.addAttribute( 'uv2', new THREE.Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n      if ( skinIndex.array.length > 0 ) geometry.addAttribute( 'skinIndex', new THREE.Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n      if ( skinWeight.array.length > 0 ) geometry.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n      build.data = geometry;\n      build.type = primitives[ 0 ].type;\n      build.materialKeys = materialKeys;\n\n      return build;\n\n    }\n\n    function buildGeometryData( primitive, source, offset, array ) {\n\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n\n      function pushVector( i ) {\n\n        var index = indices[ i + offset ] * sourceStride;\n        var length = index + sourceStride;\n\n        for ( ; index < length; index ++ ) {\n\n          array.push( sourceArray[ index ] );\n\n        }\n\n      }\n\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n\n      if ( primitive.vcount !== undefined ) {\n\n        var index = 0;\n\n        for ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\n          var count = vcount[ i ];\n\n          if ( count === 4 ) {\n\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n\n            pushVector( a ); pushVector( b ); pushVector( d );\n            pushVector( b ); pushVector( c ); pushVector( d );\n\n          } else if ( count === 3 ) {\n\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n\n            pushVector( a ); pushVector( b ); pushVector( c );\n\n          } else if ( count > 4 ) {\n\n            for ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * ( k + 1 );\n\n              pushVector( a ); pushVector( b ); pushVector( c );\n\n            }\n\n          }\n\n          index += stride * count;\n\n        }\n\n      } else {\n\n        for ( var i = 0, l = indices.length; i < l; i += stride ) {\n\n          pushVector( i );\n\n        }\n\n      }\n\n    }\n\n    function getGeometry( id ) {\n\n      return getBuild( library.geometries[ id ], buildGeometry );\n\n    }\n\n    // kinematics\n\n    function parseKinematicsModel( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ) || '',\n        joints: {},\n        links: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            parseKinematicsTechniqueCommon( child, data );\n            break;\n\n        }\n\n      }\n\n      library.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildKinematicsModel( data ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      return data;\n\n    }\n\n    function getKinematicsModel( id ) {\n\n      return getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n    }\n\n    function parseKinematicsTechniqueCommon( xml, data ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'joint':\n            data.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n            break;\n\n          case 'link':\n            data.links.push( parseKinematicsLink( child ) );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parseKinematicsJoint( xml ) {\n\n      var data;\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter( child );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseKinematicsJointParameter( xml, data ) {\n\n      var data = {\n        sid: xml.getAttribute( 'sid' ),\n        name: xml.getAttribute( 'name' ) || '',\n        axis: new THREE.Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'axis':\n            var array = parseFloats( child.textContent );\n            data.axis.fromArray( array );\n            break;\n          case 'limits':\n            var max = child.getElementsByTagName( 'max' )[ 0 ];\n            var min = child.getElementsByTagName( 'min' )[ 0 ];\n\n            data.limits.max = parseFloat( max.textContent );\n            data.limits.min = parseFloat( min.textContent );\n            break;\n\n        }\n\n      }\n\n      // if min is equal to or greater than max, consider the joint static\n\n      if ( data.limits.min >= data.limits.max ) {\n\n        data.static = true;\n\n      }\n\n      // calculate middle position\n\n      data.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n      return data;\n\n    }\n\n    function parseKinematicsLink( xml ) {\n\n      var data = {\n        sid: xml.getAttribute( 'sid' ),\n        name: xml.getAttribute( 'name' ) || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'attachment_full':\n            data.attachments.push( parseKinematicsAttachment( child ) );\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push( parseKinematicsTransform( child ) );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseKinematicsAttachment( xml ) {\n\n      var data = {\n        joint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n        transforms: [],\n        links: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'link':\n            data.links.push( parseKinematicsLink( child ) );\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push( parseKinematicsTransform( child ) );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function parseKinematicsTransform( xml ) {\n\n      var data = {\n        type: xml.nodeName\n      };\n\n      var array = parseFloats( xml.textContent );\n\n      switch ( data.type ) {\n\n        case 'matrix':\n          data.obj = new THREE.Matrix4();\n          data.obj.fromArray( array ).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray( array );\n          break;\n\n        case 'rotate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray( array );\n          data.angle = THREE.Math.degToRad( array[ 3 ] );\n          break;\n\n      }\n\n      return data;\n\n    }\n\n    // physics\n\n    function parsePhysicsModel( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ) || '',\n        rigidBodies: {}\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'rigid_body':\n            data.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n            parsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n            break;\n\n        }\n\n      }\n\n      library.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function parsePhysicsRigidBody( xml, data ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'technique_common':\n            parsePhysicsTechniqueCommon( child, data );\n            break;\n\n        }\n\n      }\n\n    }\n\n    function parsePhysicsTechniqueCommon( xml, data ) {\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'inertia':\n            data.inertia = parseFloats( child.textContent );\n            break;\n\n          case 'mass':\n            data.mass = parseFloats( child.textContent )[ 0 ];\n            break;\n\n        }\n\n      }\n\n    }\n\n    // scene\n\n    function parseKinematicsScene( xml ) {\n\n      var data = {\n        bindJointAxis: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'bind_joint_axis':\n            data.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n            break;\n\n        }\n\n      }\n\n      library.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n    }\n\n    function parseKinematicsBindJointAxis( xml ) {\n\n      var data = {\n        target: xml.getAttribute( 'target' ).split( '/' ).pop()\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'axis':\n            var param = child.getElementsByTagName( 'param' )[ 0 ];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n            data.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildKinematicsScene( data ) {\n\n      if ( data.build !== undefined ) return data.build;\n\n      return data;\n\n    }\n\n    function getKinematicsScene( id ) {\n\n      return getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n    }\n\n    function setupKinematics() {\n\n      var kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n      var kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n      var visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n      if ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n      var kinematicsModel = getKinematicsModel( kinematicsModelId );\n      var kinematicsScene = getKinematicsScene( kinematicsSceneId );\n      var visualScene = getVisualScene( visualSceneId );\n\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n\n      for ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n        var axis = bindJointAxis[ i ];\n\n        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n        if ( targetElement ) {\n\n          // get the parent of the transfrom element\n\n          var parentVisualElement = targetElement.parentElement;\n\n          // connect the joint of the kinematics model with the element in the visual scene\n\n          connect( axis.jointIndex, parentVisualElement );\n\n        }\n\n      }\n\n      function connect( jointIndex, visualElement ) {\n\n        var visualElementName = visualElement.getAttribute( 'name' );\n        var joint = kinematicsModel.joints[ jointIndex ];\n\n        visualScene.traverse( function ( object ) {\n\n          if ( object.name === visualElementName ) {\n\n            jointMap[ jointIndex ] = {\n              object: object,\n              transforms: buildTransformList( visualElement ),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n\n          }\n\n        } );\n\n      }\n\n      var m0 = new THREE.Matrix4();\n\n      kinematics = {\n\n        joints: kinematicsModel && kinematicsModel.joints,\n\n        getJointValue: function ( jointIndex ) {\n\n          var jointData = jointMap[ jointIndex ];\n\n          if ( jointData ) {\n\n            return jointData.position;\n\n          } else {\n\n            console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n          }\n\n        },\n\n        setJointValue: function ( jointIndex, value ) {\n\n          var jointData = jointMap[ jointIndex ];\n\n          if ( jointData ) {\n\n            var joint = jointData.joint;\n\n            if ( value > joint.limits.max || value < joint.limits.min ) {\n\n              console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n            } else if ( joint.static ) {\n\n              console.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n            } else {\n\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n\n              matrix.identity();\n\n              // each update, we have to apply all transforms in the correct order\n\n              for ( var i = 0; i < transforms.length; i ++ ) {\n\n                var transform = transforms[ i ];\n\n                // if there is a connection of the transform node with a joint, apply the joint value\n\n                if ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n                  switch ( joint.type ) {\n\n                    case 'revolute':\n                      matrix.multiply( m0.makeRotationAxis( axis, THREE.Math.degToRad( value ) ) );\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n                      break;\n\n                    default:\n                      console.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n                      break;\n\n                  }\n\n                } else {\n\n                  switch ( transform.type ) {\n\n                    case 'matrix':\n                      matrix.multiply( transform.obj );\n                      break;\n\n                    case 'translate':\n                      matrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n                      break;\n\n                    case 'scale':\n                      matrix.scale( transform.obj );\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n                      break;\n\n                  }\n\n                }\n\n              }\n\n              object.matrix.copy( matrix );\n              object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n              jointMap[ jointIndex ].position = value;\n\n            }\n\n          } else {\n\n            console.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n          }\n\n        }\n\n      };\n\n    }\n\n    function buildTransformList( node ) {\n\n      var transforms = [];\n\n      var xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'matrix':\n            var array = parseFloats( child.textContent );\n            var matrix = new THREE.Matrix4().fromArray( array ).transpose();\n            transforms.push( {\n              sid: child.getAttribute( 'sid' ),\n              type: child.nodeName,\n              obj: matrix\n            } );\n            break;\n\n          case 'translate':\n          case 'scale':\n            var array = parseFloats( child.textContent );\n            var vector = new THREE.Vector3().fromArray( array );\n            transforms.push( {\n              sid: child.getAttribute( 'sid' ),\n              type: child.nodeName,\n              obj: vector\n            } );\n            break;\n\n          case 'rotate':\n            var array = parseFloats( child.textContent );\n            var vector = new THREE.Vector3().fromArray( array );\n            var angle = THREE.Math.degToRad( array[ 3 ] );\n            transforms.push( {\n              sid: child.getAttribute( 'sid' ),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            } );\n            break;\n\n        }\n\n      }\n\n      return transforms;\n\n    }\n\n    // nodes\n\n    function prepareNodes( xml ) {\n\n      var elements = xml.getElementsByTagName( 'node' );\n\n      // ensure all node elements have id attributes\n\n      for ( var i = 0; i < elements.length; i ++ ) {\n\n        var element = elements[ i ];\n\n        if ( element.hasAttribute( 'id' ) === false ) {\n\n          element.setAttribute( 'id', generateId() );\n\n        }\n\n      }\n\n    }\n\n    var matrix = new THREE.Matrix4();\n    var vector = new THREE.Vector3();\n\n    function parseNode( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ) || '',\n        type: xml.getAttribute( 'type' ),\n        id: xml.getAttribute( 'id' ),\n        sid: xml.getAttribute( 'sid' ),\n        matrix: new THREE.Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        if ( child.nodeType !== 1 ) continue;\n\n        switch ( child.nodeName ) {\n\n          case 'node':\n            data.nodes.push( child.getAttribute( 'id' ) );\n            parseNode( child );\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push( parseNodeInstance( child ) );\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push( parseNodeInstance( child ) );\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n            break;\n\n          case 'matrix':\n            var array = parseFloats( child.textContent );\n            data.matrix.multiply( matrix.fromArray( array ).transpose() );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'translate':\n            var array = parseFloats( child.textContent );\n            vector.fromArray( array );\n            data.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'rotate':\n            var array = parseFloats( child.textContent );\n            var angle = THREE.Math.degToRad( array[ 3 ] );\n            data.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'scale':\n            var array = parseFloats( child.textContent );\n            data.matrix.scale( vector.fromArray( array ) );\n            data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log( child );\n\n        }\n\n      }\n\n      if ( hasNode( data.id ) ) {\n\n        console.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n      } else {\n\n        library.nodes[ data.id ] = data;\n\n      }\n\n      return data;\n\n    }\n\n    function parseNodeInstance( xml ) {\n\n      var data = {\n        id: parseId( xml.getAttribute( 'url' ) ),\n        materials: {},\n        skeletons: []\n      };\n\n      for ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n        var child = xml.childNodes[ i ];\n\n        switch ( child.nodeName ) {\n\n          case 'bind_material':\n            var instances = child.getElementsByTagName( 'instance_material' );\n\n            for ( var j = 0; j < instances.length; j ++ ) {\n\n              var instance = instances[ j ];\n              var symbol = instance.getAttribute( 'symbol' );\n              var target = instance.getAttribute( 'target' );\n\n              data.materials[ symbol ] = parseId( target );\n\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push( parseId( child.textContent ) );\n            break;\n\n          default:\n            break;\n\n        }\n\n      }\n\n      return data;\n\n    }\n\n    function buildSkeleton( skeletons, joints ) {\n\n      var boneData = [];\n      var sortedBoneData = [];\n\n      var i, j, data;\n\n      // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for ( i = 0; i < skeletons.length; i ++ ) {\n\n        var skeleton = skeletons[ i ];\n\n        var root;\n\n        if ( hasNode( skeleton ) ) {\n\n          root = getNode( skeleton );\n          buildBoneHierarchy( root, joints, boneData );\n\n        } else if ( hasVisualScene( skeleton ) ) {\n\n          // handle case where the skeleton refers to the visual scene (#13335)\n\n          var visualScene = library.visualScenes[ skeleton ];\n          var children = visualScene.children;\n\n          for ( var j = 0; j < children.length; j ++ ) {\n\n            var child = children[ j ];\n\n            if ( child.type === 'JOINT' ) {\n\n              var root = getNode( child.id );\n              buildBoneHierarchy( root, joints, boneData );\n\n            }\n\n          }\n\n        } else {\n\n          console.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n        }\n\n      }\n\n      // sort bone data (the order is defined in the corresponding controller)\n\n      for ( i = 0; i < joints.length; i ++ ) {\n\n        for ( j = 0; j < boneData.length; j ++ ) {\n\n          data = boneData[ j ];\n\n          if ( data.bone.name === joints[ i ].name ) {\n\n            sortedBoneData[ i ] = data;\n            data.processed = true;\n            break;\n\n          }\n\n        }\n\n      }\n\n      // add unprocessed bone data at the end of the list\n\n      for ( i = 0; i < boneData.length; i ++ ) {\n\n        data = boneData[ i ];\n\n        if ( data.processed === false ) {\n\n          sortedBoneData.push( data );\n          data.processed = true;\n\n        }\n\n      }\n\n      // setup arrays for skeleton creation\n\n      var bones = [];\n      var boneInverses = [];\n\n      for ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n        data = sortedBoneData[ i ];\n\n        bones.push( data.bone );\n        boneInverses.push( data.boneInverse );\n\n      }\n\n      return new THREE.Skeleton( bones, boneInverses );\n\n    }\n\n    function buildBoneHierarchy( root, joints, boneData ) {\n\n      // setup bone data from visual scene\n\n      root.traverse( function ( object ) {\n\n        if ( object.isBone === true ) {\n\n          var boneInverse;\n\n          // retrieve the boneInverse from the controller data\n\n          for ( var i = 0; i < joints.length; i ++ ) {\n\n            var joint = joints[ i ];\n\n            if ( joint.name === object.name ) {\n\n              boneInverse = joint.boneInverse;\n              break;\n\n            }\n\n          }\n\n          if ( boneInverse === undefined ) {\n\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n\n            boneInverse = new THREE.Matrix4();\n\n          }\n\n          boneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n        }\n\n      } );\n\n    }\n\n    function buildNode( data ) {\n\n      var objects = [];\n\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes;\n\n      // nodes\n\n      for ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n        objects.push( getNode( nodes[ i ] ) );\n\n      }\n\n      // instance cameras\n\n      for ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n        var instanceCamera = getCamera( instanceCameras[ i ] );\n\n        if ( instanceCamera !== null ) {\n\n          objects.push( instanceCamera.clone() );\n\n        }\n\n      }\n\n      // instance controllers\n\n      for ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n        var instance = instanceControllers[ i ];\n        var controller = getController( instance.id );\n        var geometries = getGeometry( controller.id );\n        var newObjects = buildObjects( geometries, instance.materials );\n\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n\n        var skeleton = buildSkeleton( skeletons, joints );\n\n        for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n          var object = newObjects[ j ];\n\n          if ( object.isSkinnedMesh ) {\n\n            object.bind( skeleton, controller.skin.bindMatrix );\n            object.normalizeSkinWeights();\n\n          }\n\n          objects.push( object );\n\n        }\n\n      }\n\n      // instance lights\n\n      for ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n        var instanceLight = getLight( instanceLights[ i ] );\n\n        if ( instanceLight !== null ) {\n\n          objects.push( instanceLight.clone() );\n\n        }\n\n      }\n\n      // instance geometries\n\n      for ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n        var instance = instanceGeometries[ i ];\n\n        // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry( instance.id );\n        var newObjects = buildObjects( geometries, instance.materials );\n\n        for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n          objects.push( newObjects[ j ] );\n\n        }\n\n      }\n\n      // instance nodes\n\n      for ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n        objects.push( getNode( instanceNodes[ i ] ).clone() );\n\n      }\n\n      var object;\n\n      if ( nodes.length === 0 && objects.length === 1 ) {\n\n        object = objects[ 0 ];\n\n      } else {\n\n        object = ( type === 'JOINT' ) ? new THREE.Bone() : new THREE.Group();\n\n        for ( var i = 0; i < objects.length; i ++ ) {\n\n          object.add( objects[ i ] );\n\n        }\n\n      }\n\n      if ( object.name === '' ) {\n\n        object.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\n      }\n\n      object.matrix.copy( matrix );\n      object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n      return object;\n\n    }\n\n    var fallbackMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff } );\n\n    function resolveMaterialBinding( keys, instanceMaterials ) {\n\n      var materials = [];\n\n      for ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n        var id = instanceMaterials[ keys[ i ] ];\n\n        if ( id === undefined ) {\n\n          console.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n          materials.push( fallbackMaterial );\n\n        } else {\n\n          materials.push( getMaterial( id ) );\n\n        }\n\n      }\n\n      return materials;\n\n    }\n\n    function buildObjects( geometries, instanceMaterials ) {\n\n      var objects = [];\n\n      for ( var type in geometries ) {\n\n        var geometry = geometries[ type ];\n\n        var materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n        // handle case if no materials are defined\n\n        if ( materials.length === 0 ) {\n\n          if ( type === 'lines' || type === 'linestrips' ) {\n\n            materials.push( new THREE.LineBasicMaterial() );\n\n          } else {\n\n            materials.push( new THREE.MeshPhongMaterial() );\n\n          }\n\n        }\n\n        // regard skinning\n\n        var skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n        if ( skinning ) {\n\n          for ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n            materials[ i ].skinning = true;\n\n          }\n\n        }\n\n        // choose between a single or multi materials (material array)\n\n        var material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n        // now create a specific 3D object\n\n        var object;\n\n        switch ( type ) {\n\n          case 'lines':\n            object = new THREE.LineSegments( geometry.data, material );\n            break;\n\n          case 'linestrips':\n            object = new THREE.Line( geometry.data, material );\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if ( skinning ) {\n\n              object = new THREE.SkinnedMesh( geometry.data, material );\n\n            } else {\n\n              object = new THREE.Mesh( geometry.data, material );\n\n            }\n            break;\n\n        }\n\n        objects.push( object );\n\n      }\n\n      return objects;\n\n    }\n\n    function hasNode( id ) {\n\n      return library.nodes[ id ] !== undefined;\n\n    }\n\n    function getNode( id ) {\n\n      return getBuild( library.nodes[ id ], buildNode );\n\n    }\n\n    // visual scenes\n\n    function parseVisualScene( xml ) {\n\n      var data = {\n        name: xml.getAttribute( 'name' ),\n        children: []\n      };\n\n      prepareNodes( xml );\n\n      var elements = getElementsByTagName( xml, 'node' );\n\n      for ( var i = 0; i < elements.length; i ++ ) {\n\n        data.children.push( parseNode( elements[ i ] ) );\n\n      }\n\n      library.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n    }\n\n    function buildVisualScene( data ) {\n\n      var group = new THREE.Group();\n      group.name = data.name;\n\n      var children = data.children;\n\n      for ( var i = 0; i < children.length; i ++ ) {\n\n        var child = children[ i ];\n\n        group.add( getNode( child.id ) );\n\n      }\n\n      return group;\n\n    }\n\n    function hasVisualScene( id ) {\n\n      return library.visualScenes[ id ] !== undefined;\n\n    }\n\n    function getVisualScene( id ) {\n\n      return getBuild( library.visualScenes[ id ], buildVisualScene );\n\n    }\n\n    // scenes\n\n    function parseScene( xml ) {\n\n      var instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n      return getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n    }\n\n    function setupAnimations() {\n\n      var clips = library.clips;\n\n      if ( isEmpty( clips ) === true ) {\n\n        if ( isEmpty( library.animations ) === false ) {\n\n          // if there are animations but no clips, we create a default clip for playback\n\n          var tracks = [];\n\n          for ( var id in library.animations ) {\n\n            var animationTracks = getAnimation( id );\n\n            for ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n              tracks.push( animationTracks[ i ] );\n\n            }\n\n          }\n\n          animations.push( new THREE.AnimationClip( 'default', - 1, tracks ) );\n\n        }\n\n      } else {\n\n        for ( var id in clips ) {\n\n          animations.push( getAnimationClip( id ) );\n\n        }\n\n      }\n\n    }\n\n    if ( text.length === 0 ) {\n\n      return { scene: new THREE.Scene() };\n\n    }\n\n    var xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n    var collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n    // metadata\n\n    var version = collada.getAttribute( 'version' );\n    console.log( 'THREE.ColladaLoader: File version', version );\n\n    var asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n    var textureLoader = new THREE.TextureLoader( this.manager );\n    textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n    var tgaLoader;\n\n    if ( THREE.TGALoader ) {\n\n      tgaLoader = new THREE.TGALoader( this.manager );\n      tgaLoader.setPath( this.resourcePath || path );\n\n    }\n\n    //\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0;\n\n    //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n\n    parseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n    parseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n    parseLibrary( collada, 'library_controllers', 'controller', parseController );\n    parseLibrary( collada, 'library_images', 'image', parseImage );\n    parseLibrary( collada, 'library_effects', 'effect', parseEffect );\n    parseLibrary( collada, 'library_materials', 'material', parseMaterial );\n    parseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n    parseLibrary( collada, 'library_lights', 'light', parseLight );\n    parseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n    parseLibrary( collada, 'library_nodes', 'node', parseNode );\n    parseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n    parseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n    parseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n    parseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n    buildLibrary( library.animations, buildAnimation );\n    buildLibrary( library.clips, buildAnimationClip );\n    buildLibrary( library.controllers, buildController );\n    buildLibrary( library.images, buildImage );\n    buildLibrary( library.effects, buildEffect );\n    buildLibrary( library.materials, buildMaterial );\n    buildLibrary( library.cameras, buildCamera );\n    buildLibrary( library.lights, buildLight );\n    buildLibrary( library.geometries, buildGeometry );\n    buildLibrary( library.visualScenes, buildVisualScene );\n\n    setupAnimations();\n    setupKinematics();\n\n    var scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\n    if ( asset.upAxis === 'Z_UP' ) {\n\n      scene.quaternion.setFromEuler( new THREE.Euler( - Math.PI / 2, 0, 0 ) );\n\n    }\n\n    scene.scale.multiplyScalar( asset.unit );\n\n    return {\n      animations: animations,\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}