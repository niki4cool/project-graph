{"ast":null,"code":"import _toConsumableArray from \"X:/Project/back/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"X:/Project/back/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"X:/Project/back/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\"; // math-inlining.\n\nvar abs = Math.abs,\n    min = Math.min,\n    max = Math.max,\n    cos = Math.cos,\n    sin = Math.sin,\n    acos = Math.acos,\n    sqrt = Math.sqrt;\nvar pi = Math.PI; // a zero coordinate, which is surprisingly useful\n\nvar ZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\n\nvar Bezier = /*#__PURE__*/function () {\n  function Bezier(coords) {\n    _classCallCheck(this, Bezier);\n\n    var args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    var coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      var newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    var higher = false;\n    var len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    var _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    var points = this.points = [];\n\n    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    var order = this.order = points.length - 1;\n    var dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length; // is this curve, practically speaking, a straight line?\n\n    var aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    var baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce(function (t, p) {\n      return t + abs(p.y);\n    }, 0) < baselength / 50;\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  _createClass(Bezier, [{\n    key: \"getUtils\",\n    value: function getUtils() {\n      return Bezier.getUtils();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return utils.pointsToString(this.points);\n    }\n  }, {\n    key: \"toSVG\",\n    value: function toSVG() {\n      if (this._3d) return false;\n      var p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n      for (var i = 1, last = p.length; i < last; i++) {\n        s.push(p[i].x);\n        s.push(p[i].y);\n      }\n\n      return s.join(\" \");\n    }\n  }, {\n    key: \"setRatios\",\n    value: function setRatios(ratios) {\n      if (ratios.length !== this.points.length) {\n        throw new Error(\"incorrect number of ratio values\");\n      }\n\n      this.ratios = ratios;\n      this._lut = []; //  invalidate any precomputed LUT\n    }\n  }, {\n    key: \"verify\",\n    value: function verify() {\n      var print = this.coordDigest();\n\n      if (print !== this._print) {\n        this._print = print;\n        this.update();\n      }\n    }\n  }, {\n    key: \"coordDigest\",\n    value: function coordDigest() {\n      return this.points.map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      }).join(\"\");\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // invalidate any precomputed LUT\n      this._lut = [];\n      this.dpoints = utils.derive(this.points, this._3d);\n      this.computedirection();\n    }\n  }, {\n    key: \"computedirection\",\n    value: function computedirection() {\n      var points = this.points;\n      var angle = utils.angle(points[0], points[this.order], points[1]);\n      this.clockwise = angle > 0;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return utils.length(this.derivative.bind(this));\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC(t, B) {\n      B = B || this.get(t);\n      var S = this.points[0];\n      var E = this.points[this.order];\n      return Bezier.getABC(this.order, S, B, E, t);\n    }\n  }, {\n    key: \"getLUT\",\n    value: function getLUT(steps) {\n      this.verify();\n      steps = steps || 100;\n\n      if (this._lut.length === steps) {\n        return this._lut;\n      }\n\n      this._lut = []; // n steps means n+1 points\n\n      steps++;\n      this._lut = [];\n\n      for (var i = 0, p, _t; i < steps; i++) {\n        _t = i / (steps - 1);\n        p = this.compute(_t);\n        p.t = _t;\n\n        this._lut.push(p);\n      }\n\n      return this._lut;\n    }\n  }, {\n    key: \"on\",\n    value: function on(point, error) {\n      error = error || 5;\n      var lut = this.getLUT(),\n          hits = [];\n\n      for (var i = 0, c, _t2 = 0; i < lut.length; i++) {\n        c = lut[i];\n\n        if (utils.dist(c, point) < error) {\n          hits.push(c);\n          _t2 += i / lut.length;\n        }\n      }\n\n      if (!hits.length) return false;\n      return t /= hits.length;\n    }\n  }, {\n    key: \"project\",\n    value: function project(point) {\n      // step 1: coarse check\n      var LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils.closest(LUT, point),\n          mpos = closest.mpos,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l; // step 2: fine check\n\n      var mdist = closest.mdist,\n          t = t1,\n          ft = t,\n          p;\n      mdist += 1;\n\n      for (var d; t < t2 + step; t += step) {\n        p = this.compute(t);\n        d = utils.dist(point, p);\n\n        if (d < mdist) {\n          mdist = d;\n          ft = t;\n        }\n      }\n\n      ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n      p = this.compute(ft);\n      p.t = ft;\n      p.d = mdist;\n      return p;\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.compute(t);\n    }\n  }, {\n    key: \"point\",\n    value: function point(idx) {\n      return this.points[idx];\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(t) {\n      if (this.ratios) {\n        return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n      }\n\n      return utils.compute(t, this.points, this._3d, this.ratios);\n    }\n  }, {\n    key: \"raise\",\n    value: function raise() {\n      var p = this.points,\n          np = [p[0]],\n          k = p.length;\n\n      for (var i = 1, _pi, pim; i < k; i++) {\n        _pi = p[i];\n        pim = p[i - 1];\n        np[i] = {\n          x: (k - i) / k * _pi.x + i / k * pim.x,\n          y: (k - i) / k * _pi.y + i / k * pim.y\n        };\n      }\n\n      np[k] = p[k - 1];\n      return new Bezier(np);\n    }\n  }, {\n    key: \"derivative\",\n    value: function derivative(t) {\n      return utils.compute(t, this.dpoints[0], this._3d);\n    }\n  }, {\n    key: \"dderivative\",\n    value: function dderivative(t) {\n      return utils.compute(t, this.dpoints[1], this._3d);\n    }\n  }, {\n    key: \"align\",\n    value: function align() {\n      var p = this.points;\n      return new Bezier(utils.align(p, {\n        p1: p[0],\n        p2: p[p.length - 1]\n      }));\n    }\n  }, {\n    key: \"curvature\",\n    value: function curvature(t) {\n      return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n    }\n  }, {\n    key: \"inflections\",\n    value: function inflections() {\n      return utils.inflections(this.points);\n    }\n  }, {\n    key: \"normal\",\n    value: function normal(t) {\n      return this._3d ? this.__normal3(t) : this.__normal2(t);\n    }\n  }, {\n    key: \"__normal2\",\n    value: function __normal2(t) {\n      var d = this.derivative(t);\n      var q = sqrt(d.x * d.x + d.y * d.y);\n      return {\n        t: t,\n        x: -d.y / q,\n        y: d.x / q\n      };\n    }\n  }, {\n    key: \"__normal3\",\n    value: function __normal3(t) {\n      // see http://stackoverflow.com/questions/25453159\n      var r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n      r1.x /= q1;\n      r1.y /= q1;\n      r1.z /= q1;\n      r2.x /= q2;\n      r2.y /= q2;\n      r2.z /= q2; // cross product\n\n      var c = {\n        x: r2.y * r1.z - r2.z * r1.y,\n        y: r2.z * r1.x - r2.x * r1.z,\n        z: r2.x * r1.y - r2.y * r1.x\n      };\n      var m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n      c.x /= m;\n      c.y /= m;\n      c.z /= m; // rotation matrix\n\n      var R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n      var n = {\n        t: t,\n        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n      };\n      return n;\n    }\n  }, {\n    key: \"hull\",\n    value: function hull(t) {\n      var p = this.points,\n          _p = [],\n          q = [],\n          idx = 0;\n      q[idx++] = p[0];\n      q[idx++] = p[1];\n      q[idx++] = p[2];\n\n      if (this.order === 3) {\n        q[idx++] = p[3];\n      } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n      while (p.length > 1) {\n        _p = [];\n\n        for (var i = 0, pt, l = p.length - 1; i < l; i++) {\n          pt = utils.lerp(t, p[i], p[i + 1]);\n          q[idx++] = pt;\n\n          _p.push(pt);\n        }\n\n        p = _p;\n      }\n\n      return q;\n    }\n  }, {\n    key: \"split\",\n    value: function split(t1, t2) {\n      // shortcuts\n      if (t1 === 0 && !!t2) {\n        return this.split(t2).left;\n      }\n\n      if (t2 === 1) {\n        return this.split(t1).right;\n      } // no shortcut: use \"de Casteljau\" iteration.\n\n\n      var q = this.hull(t1);\n      var result = {\n        left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n        right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n        span: q\n      }; // make sure we bind _t1/_t2 information!\n\n      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n      if (!t2) {\n        return result;\n      } // if we have a t2, split again:\n\n\n      t2 = utils.map(t2, t1, 1, 0, 1);\n      return result.right.split(t2).left;\n    }\n  }, {\n    key: \"extrema\",\n    value: function extrema() {\n      var result = {};\n      var roots = [];\n      this.dims.forEach(function (dim) {\n        var mfn = function mfn(v) {\n          return v[dim];\n        };\n\n        var p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this));\n      result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n        return roots.indexOf(v) === idx;\n      });\n      return result;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var extrema = this.extrema(),\n          result = {};\n      this.dims.forEach(function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this));\n      return result;\n    }\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(curve) {\n      var lbbox = this.bbox(),\n          tbbox = curve.bbox();\n      return utils.bboxoverlap(lbbox, tbbox);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(t, d) {\n      if (typeof d !== \"undefined\") {\n        var c = this.get(t),\n            n = this.normal(t);\n        var ret = {\n          c: c,\n          n: n,\n          x: c.x + n.x * d,\n          y: c.y + n.y * d\n        };\n\n        if (this._3d) {\n          ret.z = c.z + n.z * d;\n        }\n\n        return ret;\n      }\n\n      if (this._linear) {\n        var nv = this.normal(0),\n            coords = this.points.map(function (p) {\n          var ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y\n          };\n\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n\n          return ret;\n        });\n        return [new Bezier(coords)];\n      }\n\n      return this.reduce().map(function (s) {\n        if (s._linear) {\n          return s.offset(t)[0];\n        }\n\n        return s.scale(t);\n      });\n    }\n  }, {\n    key: \"simple\",\n    value: function simple() {\n      if (this.order === 3) {\n        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n      }\n\n      var n1 = this.normal(0);\n      var n2 = this.normal(1);\n      var s = n1.x * n2.x + n1.y * n2.y;\n\n      if (this._3d) {\n        s += n1.z * n2.z;\n      }\n\n      return abs(acos(s)) < pi / 3;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce() {\n      // TODO: examine these var types in more detail...\n      var i,\n          t1 = 0,\n          t2 = 0,\n          step = 0.01,\n          segment,\n          pass1 = [],\n          pass2 = []; // first pass: split on extrema\n\n      var extrema = this.extrema().values;\n\n      if (extrema.indexOf(0) === -1) {\n        extrema = [0].concat(extrema);\n      }\n\n      if (extrema.indexOf(1) === -1) {\n        extrema.push(1);\n      }\n\n      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n        t2 = extrema[i];\n        segment = this.split(t1, t2);\n        segment._t1 = t1;\n        segment._t2 = t2;\n        pass1.push(segment);\n        t1 = t2;\n      } // second pass: further reduce these segments to simple segments\n\n\n      pass1.forEach(function (p1) {\n        t1 = 0;\n        t2 = 0;\n\n        while (t2 <= 1) {\n          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n            segment = p1.split(t1, t2);\n\n            if (!segment.simple()) {\n              t2 -= step;\n\n              if (abs(t1 - t2) < step) {\n                // we can never form a reduction\n                return [];\n              }\n\n              segment = p1.split(t1, t2);\n              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n              pass2.push(segment);\n              t1 = t2;\n              break;\n            }\n          }\n        }\n\n        if (t1 < 1) {\n          segment = p1.split(t1, 1);\n          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n          segment._t2 = p1._t2;\n          pass2.push(segment);\n        }\n      });\n      return pass2;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(v, d1, d2) {\n      d2 = typeof d2 === \"number\" ? d2 : d1; // TODO: make this take curves with control points outside\n      //       of the start-end interval into account\n\n      var o = this.order;\n      var d = this.points.map(function (_, i) {\n        return (1 - i / o) * d1 + i / o * d2;\n      });\n      return new Bezier(this.points.map(function (p, i) {\n        return {\n          x: p.x + v.x * d[i],\n          y: p.y + v.y * d[i]\n        };\n      }));\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(d) {\n      var _this = this;\n\n      var order = this.order;\n      var distanceFn = false;\n\n      if (typeof d === \"function\") {\n        distanceFn = d;\n      }\n\n      if (distanceFn && order === 2) {\n        return this.raise().scale(distanceFn);\n      } // TODO: add special handling for non-linear degenerate curves.\n\n\n      var clockwise = this.clockwise;\n      var points = this.points;\n\n      if (this._linear) {\n        return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d, distanceFn ? distanceFn(1) : d);\n      }\n\n      var r1 = distanceFn ? distanceFn(0) : d;\n      var r2 = distanceFn ? distanceFn(1) : d;\n      var v = [this.offset(0, 10), this.offset(1, 10)];\n      var np = [];\n      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n      if (!o) {\n        throw new Error(\"cannot scale this curve. Try reducing it first.\");\n      } // move all points by distance 'd' wrt the origin 'o',\n      // and move end points by fixed distance along normal.\n\n\n      [0, 1].forEach(function (t) {\n        var p = np[t * order] = utils.copy(points[t * order]);\n        p.x += (t ? r2 : r1) * v[t].n.x;\n        p.y += (t ? r2 : r1) * v[t].n.y;\n      });\n\n      if (!distanceFn) {\n        // move control points to lie on the intersection of the offset\n        // derivative vector, and the origin-through-control vector\n        [0, 1].forEach(function (t) {\n          if (order === 2 && !!t) return;\n          var p = np[t * order];\n\n          var d = _this.derivative(t);\n\n          var p2 = {\n            x: p.x + d.x,\n            y: p.y + d.y\n          };\n          np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n        });\n        return new Bezier(np);\n      } // move control points by \"however much necessary to\n      // ensure the correct tangent to endpoint\".\n\n\n      [0, 1].forEach(function (t) {\n        if (order === 2 && !!t) return;\n        var p = points[t + 1];\n        var ov = {\n          x: p.x - o.x,\n          y: p.y - o.y\n        };\n        var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n        if (distanceFn && !clockwise) rc = -rc;\n        var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n        ov.x /= m;\n        ov.y /= m;\n        np[t + 1] = {\n          x: p.x + rc * ov.x,\n          y: p.y + rc * ov.y\n        };\n      });\n      return new Bezier(np);\n    }\n  }, {\n    key: \"outline\",\n    value: function outline(d1, d2, d3, d4) {\n      d2 = d2 === undefined ? d1 : d2;\n\n      if (this._linear) {\n        // TODO: find the actual extrema, because they might\n        //       be before the start, or past the end.\n        var n = this.normal(0);\n        var start = this.points[0];\n        var end = this.points[this.points.length - 1];\n        var s, mid, e;\n\n        if (d3 === undefined) {\n          d3 = d1;\n          d4 = d2;\n        }\n\n        s = {\n          x: start.x + n.x * d1,\n          y: start.y + n.y * d1\n        };\n        e = {\n          x: end.x + n.x * d3,\n          y: end.y + n.y * d3\n        };\n        mid = {\n          x: (s.x + e.x) / 2,\n          y: (s.y + e.y) / 2\n        };\n        var fline = [s, mid, e];\n        s = {\n          x: start.x - n.x * d2,\n          y: start.y - n.y * d2\n        };\n        e = {\n          x: end.x - n.x * d4,\n          y: end.y - n.y * d4\n        };\n        mid = {\n          x: (s.x + e.x) / 2,\n          y: (s.y + e.y) / 2\n        };\n        var bline = [e, mid, s];\n\n        var _ls = utils.makeline(bline[2], fline[0]);\n\n        var _le = utils.makeline(fline[2], bline[0]);\n\n        var _segments = [_ls, new Bezier(fline), _le, new Bezier(bline)];\n        return new PolyBezier(_segments);\n      }\n\n      var reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [];\n      var bcurves = [],\n          p,\n          alen = 0,\n          tlen = this.length();\n      var graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n      function linearDistanceFunction(s, e, tlen, alen, slen) {\n        return function (v) {\n          var f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n        };\n      } // form curve oulines\n\n\n      reduced.forEach(function (segment) {\n        var slen = segment.length();\n\n        if (graduated) {\n          fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n          bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n        } else {\n          fcurves.push(segment.scale(d1));\n          bcurves.push(segment.scale(-d2));\n        }\n\n        alen += slen;\n      }); // reverse the \"return\" outline\n\n      bcurves = bcurves.map(function (s) {\n        p = s.points;\n\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n\n        return s;\n      }).reverse(); // form the endcaps as lines\n\n      var fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils.makeline(bs, fs),\n          le = utils.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n      return new PolyBezier(segments);\n    }\n  }, {\n    key: \"outlineshapes\",\n    value: function outlineshapes(d1, d2, curveIntersectionThreshold) {\n      d2 = d2 || d1;\n      var outline = this.outline(d1, d2).curves;\n      var shapes = [];\n\n      for (var i = 1, len = outline.length; i < len / 2; i++) {\n        var shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n        shape.startcap.virtual = i > 1;\n        shape.endcap.virtual = i < len / 2 - 1;\n        shapes.push(shape);\n      }\n\n      return shapes;\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(curve, curveIntersectionThreshold) {\n      if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n      if (curve.p1 && curve.p2) {\n        return this.lineIntersects(curve);\n      }\n\n      if (curve instanceof Bezier) {\n        curve = curve.reduce();\n      }\n\n      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n    }\n  }, {\n    key: \"lineIntersects\",\n    value: function lineIntersects(line) {\n      var _this2 = this;\n\n      var mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y);\n      return utils.roots(this.points, line).filter(function (t) {\n        var p = _this2.get(t);\n\n        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n      });\n    }\n  }, {\n    key: \"selfintersects\",\n    value: function selfintersects(curveIntersectionThreshold) {\n      // \"simple\" curves cannot intersect with their direct\n      // neighbour, so for each segment X we check whether\n      // it intersects [0:x-2][x+2:last].\n      var reduced = this.reduce(),\n          len = reduced.length - 2,\n          results = [];\n\n      for (var i = 0, result, left, right; i < len; i++) {\n        left = reduced.slice(i, i + 1);\n        right = reduced.slice(i + 2);\n        result = this.curveintersects(left, right, curveIntersectionThreshold);\n        results.push.apply(results, _toConsumableArray(result));\n      }\n\n      return results;\n    }\n  }, {\n    key: \"curveintersects\",\n    value: function curveintersects(c1, c2, curveIntersectionThreshold) {\n      var pairs = []; // step 1: pair off any overlapping segments\n\n      c1.forEach(function (l) {\n        c2.forEach(function (r) {\n          if (l.overlaps(r)) {\n            pairs.push({\n              left: l,\n              right: r\n            });\n          }\n        });\n      }); // step 2: for each pairing, run through the convergence algorithm.\n\n      var intersections = [];\n      pairs.forEach(function (pair) {\n        var result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n        if (result.length > 0) {\n          intersections = intersections.concat(result);\n        }\n      });\n      return intersections;\n    }\n  }, {\n    key: \"arcs\",\n    value: function arcs(errorThreshold) {\n      errorThreshold = errorThreshold || 0.5;\n      return this._iterate(errorThreshold, []);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(pc, np1, s, e) {\n      var q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils.dist(pc, np1),\n          d1 = utils.dist(pc, c1),\n          d2 = utils.dist(pc, c2);\n      return abs(d1 - ref) + abs(d2 - ref);\n    }\n  }, {\n    key: \"_iterate\",\n    value: function _iterate(errorThreshold, circles) {\n      var t_s = 0,\n          t_e = 1,\n          safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n      do {\n        safety = 0; // step 1: start with the maximum possible arc\n\n        t_e = 1; // points:\n\n        var np1 = this.get(t_s),\n            np2 = void 0,\n            np3 = void 0,\n            arc = void 0,\n            prev_arc = void 0; // booleans:\n\n        var curr_good = false,\n            prev_good = false,\n            done = void 0; // numbers:\n\n        var t_m = t_e,\n            prev_e = 1,\n            step = 0; // step 2: find the best possible arc\n\n        do {\n          prev_good = curr_good;\n          prev_arc = arc;\n          t_m = (t_s + t_e) / 2;\n          step++;\n          np2 = this.get(t_m);\n          np3 = this.get(t_e);\n          arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n          arc.interval = {\n            start: t_s,\n            end: t_e\n          };\n\n          var error = this._error(arc, np1, t_s, t_e);\n\n          curr_good = error <= errorThreshold;\n          done = prev_good && !curr_good;\n          if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n          if (curr_good) {\n            // if e is already at max, then we're done for this arc.\n            if (t_e >= 1) {\n              // make sure we cap at t=1\n              arc.interval.end = prev_e = 1;\n              prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n              // the arc's end angle is correct with respect to the bezier end point.\n\n              if (t_e > 1) {\n                var d = {\n                  x: arc.x + arc.r * cos(arc.e),\n                  y: arc.y + arc.r * sin(arc.e)\n                };\n                arc.e += utils.angle({\n                  x: arc.x,\n                  y: arc.y\n                }, d, this.get(1));\n              }\n\n              break;\n            } // if not, move it up by half the iteration distance\n\n\n            t_e = t_e + (t_e - t_s) / 2;\n          } else {\n            // this is a bad arc: we need to move 'e' down to find a good arc\n            t_e = t_m;\n          }\n        } while (!done && safety++ < 100);\n\n        if (safety >= 100) {\n          break;\n        } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n        prev_arc = prev_arc ? prev_arc : arc;\n        circles.push(prev_arc);\n        t_s = prev_e;\n      } while (t_e < 1);\n\n      return circles;\n    }\n  }], [{\n    key: \"quadraticFromPoints\",\n    value: function quadraticFromPoints(p1, p2, p3, t) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      } // shortcuts, although they're really dumb\n\n\n      if (t === 0) {\n        return new Bezier(p2, p2, p3);\n      }\n\n      if (t === 1) {\n        return new Bezier(p1, p2, p2);\n      } // real fitting.\n\n\n      var abc = Bezier.getABC(2, p1, p2, p3, t);\n      return new Bezier(p1, abc.A, p3);\n    }\n  }, {\n    key: \"cubicFromPoints\",\n    value: function cubicFromPoints(S, B, E, t, d1) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      }\n\n      var abc = Bezier.getABC(3, S, B, E, t);\n\n      if (typeof d1 === \"undefined\") {\n        d1 = utils.dist(B, abc.C);\n      }\n\n      var d2 = d1 * (1 - t) / t;\n      var selen = utils.dist(S, E),\n          lx = (E.x - S.x) / selen,\n          ly = (E.y - S.y) / selen,\n          bx1 = d1 * lx,\n          by1 = d1 * ly,\n          bx2 = d2 * lx,\n          by2 = d2 * ly; // derivation of new hull coordinates\n\n      var e1 = {\n        x: B.x - bx1,\n        y: B.y - by1\n      },\n          e2 = {\n        x: B.x + bx2,\n        y: B.y + by2\n      },\n          A = abc.A,\n          v1 = {\n        x: A.x + (e1.x - A.x) / (1 - t),\n        y: A.y + (e1.y - A.y) / (1 - t)\n      },\n          v2 = {\n        x: A.x + (e2.x - A.x) / t,\n        y: A.y + (e2.y - A.y) / t\n      },\n          nc1 = {\n        x: S.x + (v1.x - S.x) / t,\n        y: S.y + (v1.y - S.y) / t\n      },\n          nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t)\n      }; // ...done\n\n      return new Bezier(S, nc1, nc2, E);\n    }\n  }, {\n    key: \"getUtils\",\n    value: function getUtils() {\n      return utils;\n    }\n  }, {\n    key: \"PolyBezier\",\n    get: function get() {\n      return PolyBezier;\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC() {\n      var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var S = arguments.length > 1 ? arguments[1] : undefined;\n      var B = arguments.length > 2 ? arguments[2] : undefined;\n      var E = arguments.length > 3 ? arguments[3] : undefined;\n      var t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n      var u = utils.projectionratio(t, order),\n          um = 1 - u,\n          C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y\n      },\n          s = utils.abcratio(t, order),\n          A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s\n      };\n      return {\n        A: A,\n        B: B,\n        C: C,\n        S: S,\n        E: E\n      };\n    }\n  }]);\n\n  return Bezier;\n}();\n\nexport { Bezier };","map":{"version":3,"names":["utils","PolyBezier","abs","Math","min","max","cos","sin","acos","sqrt","pi","PI","ZERO","x","y","z","Bezier","coords","args","forEach","Array","from","arguments","slice","coordlen","length","newargs","point","d","push","higher","len","Error","_3d","points","idx","step","order","dims","dimlen","aligned","align","p1","p2","baselength","dist","_linear","reduce","t","p","_lut","_t1","_t2","update","getUtils","toString","pointsToString","s","i","last","join","ratios","print","coordDigest","_print","map","c","pos","dpoints","derive","computedirection","angle","clockwise","derivative","bind","B","get","S","E","getABC","steps","verify","compute","error","lut","getLUT","hits","LUT","l","closest","mpos","t1","t2","mdist","ft","computeWithRatios","np","k","pim","curvature","inflections","__normal3","__normal2","q","r1","r2","q1","q2","m","R","n","_p","pt","lerp","split","left","right","hull","result","span","roots","dim","mfn","v","droots","concat","filter","sort","numberSort","values","indexOf","extrema","getminmax","curve","lbbox","bbox","tbbox","bboxoverlap","normal","ret","nv","offset","scale","a1","a2","n1","n2","segment","pass1","pass2","simple","d1","d2","o","_","distanceFn","raise","translate","lli4","copy","ov","rc","d3","d4","undefined","start","end","mid","e","fline","bline","ls","makeline","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","f1","f2","reverse","fs","fe","bs","be","curveIntersectionThreshold","outline","curves","shapes","shape","makeshape","startcap","virtual","endcap","selfintersects","lineIntersects","curveintersects","line","mx","my","MX","MY","between","results","c1","c2","pairs","r","overlaps","intersections","pair","pairiteration","errorThreshold","_iterate","pc","np1","ref","circles","t_s","t_e","safety","np2","np3","arc","prev_arc","curr_good","prev_good","done","t_m","prev_e","getccenter","interval","_error","p3","abc","A","C","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","v1","v2","nc1","nc2","u","projectionratio","um","abcratio"],"sources":["X:/Project/back/node_modules/bezier-js/src/bezier.js"],"sourcesContent":["/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}