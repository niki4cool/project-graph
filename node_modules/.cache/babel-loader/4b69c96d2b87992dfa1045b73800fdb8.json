{"ast":null,"code":"var e = function e() {};\n\ne.computeCentroids = function (e) {\n  var t, n, r;\n\n  for (t = 0, n = e.faces.length; t < n; t++) {\n    (r = e.faces[t]).centroid = new THREE.Vector3(0, 0, 0), r.centroid.add(e.vertices[r.a]), r.centroid.add(e.vertices[r.b]), r.centroid.add(e.vertices[r.c]), r.centroid.divideScalar(3);\n  }\n}, e.roundNumber = function (e, t) {\n  return Number(e.toFixed(t));\n}, e.sample = function (e) {\n  return e[Math.floor(Math.random() * e.length)];\n}, e.mergeVertexIds = function (e, t) {\n  var n = [];\n  if (e.forEach(function (e) {\n    t.indexOf(e) >= 0 && n.push(e);\n  }), n.length < 2) return [];\n  n.includes(e[0]) && n.includes(e[e.length - 1]) && e.push(e.shift()), n.includes(t[0]) && n.includes(t[t.length - 1]) && t.push(t.shift()), n = [], e.forEach(function (e) {\n    t.includes(e) && n.push(e);\n  });\n\n  for (var r = n[1], o = n[0], i = e.slice(); i[0] !== r;) {\n    i.push(i.shift());\n  }\n\n  for (var s = 0, u = t.slice(); u[0] !== o;) {\n    if (u.push(u.shift()), s++ > 10) throw new Error(\"Unexpected state\");\n  }\n\n  return u.shift(), u.pop(), i = i.concat(u);\n}, e.setPolygonCentroid = function (e, t) {\n  var n = new THREE.Vector3(),\n      r = t.vertices;\n  e.vertexIds.forEach(function (e) {\n    n.add(r[e]);\n  }), n.divideScalar(e.vertexIds.length), e.centroid.copy(n);\n}, e.cleanPolygon = function (e, t) {\n  for (var n = [], r = t.vertices, o = 0; o < e.vertexIds.length; o++) {\n    var i,\n        s,\n        u,\n        c = r[e.vertexIds[o]];\n    0 === o ? (i = e.vertexIds[1], s = e.vertexIds[e.vertexIds.length - 1]) : o === e.vertexIds.length - 1 ? (i = e.vertexIds[0], s = e.vertexIds[e.vertexIds.length - 2]) : (i = e.vertexIds[o + 1], s = e.vertexIds[o - 1]), u = r[s];\n    var h = r[i].clone().sub(c),\n        a = u.clone().sub(c),\n        d = h.angleTo(a);\n\n    if (d > Math.PI - .01 && d < Math.PI + .01) {\n      var f = [];\n      e.neighbours.forEach(function (t) {\n        t.vertexIds.includes(e.vertexIds[o]) || f.push(t);\n      }), e.neighbours = f;\n    } else n.push(e.vertexIds[o]);\n  }\n\n  e.vertexIds = n, this.setPolygonCentroid(e, t);\n}, e.isConvex = function (e, t) {\n  var n = t.vertices;\n  if (e.vertexIds.length < 3) return !1;\n\n  for (var r = !0, o = [], i = 0; i < e.vertexIds.length; i++) {\n    var s,\n        u,\n        c = n[e.vertexIds[i]];\n    0 === i ? (s = n[e.vertexIds[1]], u = n[e.vertexIds[e.vertexIds.length - 1]]) : i === e.vertexIds.length - 1 ? (s = n[e.vertexIds[0]], u = n[e.vertexIds[e.vertexIds.length - 2]]) : (s = n[e.vertexIds[i + 1]], u = n[e.vertexIds[i - 1]]);\n    var h = s.clone().sub(c),\n        a = u.clone().sub(c),\n        d = h.angleTo(a);\n    if (d === Math.PI || 0 === d) return !1;\n    var f = h.cross(a).y;\n    o.push(f);\n  }\n\n  return o.forEach(function (e) {\n    0 === e && (r = !1);\n  }), o.forEach(o[0] > 0 ? function (e) {\n    e < 0 && (r = !1);\n  } : function (e) {\n    e > 0 && (r = !1);\n  }), r;\n}, e.distanceToSquared = function (e, t) {\n  var n = e.x - t.x,\n      r = e.y - t.y,\n      o = e.z - t.z;\n  return n * n + r * r + o * o;\n}, e.isPointInPoly = function (e, t) {\n  for (var n = !1, r = -1, o = e.length, i = o - 1; ++r < o; i = r) {\n    (e[r].z <= t.z && t.z < e[i].z || e[i].z <= t.z && t.z < e[r].z) && t.x < (e[i].x - e[r].x) * (t.z - e[r].z) / (e[i].z - e[r].z) + e[r].x && (n = !n);\n  }\n\n  return n;\n}, e.isVectorInPolygon = function (e, t, n) {\n  var r = 1e5,\n      o = -1e5,\n      i = [];\n  return t.vertexIds.forEach(function (e) {\n    r = Math.min(n[e].y, r), o = Math.max(n[e].y, o), i.push(n[e]);\n  }), !!(e.y < o + .5 && e.y > r - .5 && this.isPointInPoly(i, e));\n}, e.triarea2 = function (e, t, n) {\n  return (n.x - e.x) * (t.z - e.z) - (t.x - e.x) * (n.z - e.z);\n}, e.vequal = function (e, t) {\n  return this.distanceToSquared(e, t) < 1e-5;\n};\n\nvar t = function t(e) {\n  this.content = [], this.scoreFunction = e;\n};\n\nt.prototype.push = function (e) {\n  this.content.push(e), this.sinkDown(this.content.length - 1);\n}, t.prototype.pop = function () {\n  var e = this.content[0],\n      t = this.content.pop();\n  return this.content.length > 0 && (this.content[0] = t, this.bubbleUp(0)), e;\n}, t.prototype.remove = function (e) {\n  var t = this.content.indexOf(e),\n      n = this.content.pop();\n  t !== this.content.length - 1 && (this.content[t] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.sinkDown(t) : this.bubbleUp(t));\n}, t.prototype.size = function () {\n  return this.content.length;\n}, t.prototype.rescoreElement = function (e) {\n  this.sinkDown(this.content.indexOf(e));\n}, t.prototype.sinkDown = function (e) {\n  for (var t = this.content[e]; e > 0;) {\n    var n = (e + 1 >> 1) - 1,\n        r = this.content[n];\n    if (!(this.scoreFunction(t) < this.scoreFunction(r))) break;\n    this.content[n] = t, this.content[e] = r, e = n;\n  }\n}, t.prototype.bubbleUp = function (e) {\n  for (var t = this.content.length, n = this.content[e], r = this.scoreFunction(n);;) {\n    var o = e + 1 << 1,\n        i = o - 1,\n        s = null,\n        u = void 0;\n    if (i < t) (u = this.scoreFunction(this.content[i])) < r && (s = i);\n    if (o < t) this.scoreFunction(this.content[o]) < (null === s ? r : u) && (s = o);\n    if (null === s) break;\n    this.content[e] = this.content[s], this.content[s] = n, e = s;\n  }\n};\n\nvar n = function n() {};\n\nn.init = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    n.f = 0, n.g = 0, n.h = 0, n.cost = 1, n.visited = !1, n.closed = !1, n.parent = null;\n  }\n}, n.cleanUp = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    delete n.f, delete n.g, delete n.h, delete n.cost, delete n.visited, delete n.closed, delete n.parent;\n  }\n}, n.heap = function () {\n  return new t(function (e) {\n    return e.f;\n  });\n}, n.search = function (e, t, n) {\n  this.init(e);\n  var r = this.heap();\n\n  for (r.push(t); r.size() > 0;) {\n    var o = r.pop();\n\n    if (o === n) {\n      for (var i = o, s = []; i.parent;) {\n        s.push(i), i = i.parent;\n      }\n\n      return this.cleanUp(s), s.reverse();\n    }\n\n    o.closed = !0;\n\n    for (var u = this.neighbours(e, o), c = 0, h = u.length; c < h; c++) {\n      var a = u[c];\n\n      if (!a.closed) {\n        var d = o.g + a.cost,\n            f = a.visited;\n\n        if (!f || d < a.g) {\n          if (a.visited = !0, a.parent = o, !a.centroid || !n.centroid) throw new Error(\"Unexpected state\");\n          a.h = a.h || this.heuristic(a.centroid, n.centroid), a.g = d, a.f = a.g + a.h, f ? r.rescoreElement(a) : r.push(a);\n        }\n      }\n    }\n  }\n\n  return [];\n}, n.heuristic = function (t, n) {\n  return e.distanceToSquared(t, n);\n}, n.neighbours = function (e, t) {\n  for (var n = [], r = 0; r < t.neighbours.length; r++) {\n    n.push(e[t.neighbours[r]]);\n  }\n\n  return n;\n};\n\nvar r = 1,\n    o = function o() {};\n\no.buildZone = function (t) {\n  var n = this,\n      r = this._buildNavigationMesh(t),\n      o = {};\n\n  r.vertices.forEach(function (t) {\n    t.x = e.roundNumber(t.x, 2), t.y = e.roundNumber(t.y, 2), t.z = e.roundNumber(t.z, 2);\n  }), o.vertices = r.vertices;\n\n  var i = this._buildPolygonGroups(r);\n\n  o.groups = [];\n\n  var s = function s(e, t) {\n    for (var n = 0; n < e.length; n++) {\n      if (t === e[n]) return n;\n    }\n  };\n\n  return i.forEach(function (t) {\n    var r = [];\n    t.forEach(function (o) {\n      var i = o.neighbours.map(function (e) {\n        return s(t, e);\n      }),\n          u = o.neighbours.map(function (e) {\n        return n._getSharedVerticesInOrder(o, e);\n      });\n      o.centroid.x = e.roundNumber(o.centroid.x, 2), o.centroid.y = e.roundNumber(o.centroid.y, 2), o.centroid.z = e.roundNumber(o.centroid.z, 2), r.push({\n        id: s(t, o),\n        neighbours: i,\n        vertexIds: o.vertexIds,\n        centroid: o.centroid,\n        portals: u\n      });\n    }), o.groups.push(r);\n  }), o;\n}, o._buildNavigationMesh = function (t) {\n  return e.computeCentroids(t), t.mergeVertices(), this._buildPolygonsFromGeometry(t);\n}, o._buildPolygonGroups = function (e) {\n  var t = [],\n      n = 0,\n      r = function r(e) {\n    e.neighbours.forEach(function (t) {\n      void 0 === t.group && (t.group = e.group, r(t));\n    });\n  };\n\n  return e.polygons.forEach(function (e) {\n    void 0 === e.group && (e.group = n++, r(e)), t[e.group] || (t[e.group] = []), t[e.group].push(e);\n  }), t;\n}, o._buildPolygonNeighbours = function (e, t, n) {\n  var r = new Set(),\n      o = n.get(e.vertexIds[0]),\n      i = n.get(e.vertexIds[1]),\n      s = n.get(e.vertexIds[2]);\n  o.forEach(function (e) {\n    (i.has(e) || s.has(e)) && r.add(t.polygons[e]);\n  }), i.forEach(function (e) {\n    s.has(e) && r.add(t.polygons[e]);\n  }), e.neighbours = Array.from(r);\n}, o._buildPolygonsFromGeometry = function (e) {\n  for (var t = this, n = [], o = e.vertices, i = e.faceVertexUvs, s = new Map(), u = 0; u < o.length; u++) {\n    s.set(u, new Set());\n  }\n\n  e.faces.forEach(function (e) {\n    n.push({\n      id: r++,\n      vertexIds: [e.a, e.b, e.c],\n      centroid: e.centroid,\n      normal: e.normal,\n      neighbours: []\n    }), s.get(e.a).add(n.length - 1), s.get(e.b).add(n.length - 1), s.get(e.c).add(n.length - 1);\n  });\n  var c = {\n    polygons: n,\n    vertices: o,\n    faceVertexUvs: i\n  };\n  return n.forEach(function (e) {\n    t._buildPolygonNeighbours(e, c, s);\n  }), c;\n}, o._getSharedVerticesInOrder = function (e, t) {\n  var n = e.vertexIds,\n      r = t.vertexIds,\n      o = new Set();\n  if (n.forEach(function (e) {\n    r.includes(e) && o.add(e);\n  }), o.size < 2) return [];\n  o.has(n[0]) && o.has(n[n.length - 1]) && n.push(n.shift()), o.has(r[0]) && o.has(r[r.length - 1]) && r.push(r.shift());\n  var i = [];\n  return n.forEach(function (e) {\n    r.includes(e) && i.push(e);\n  }), i;\n};\n\nvar i = function i() {\n  this.portals = [];\n};\n\ni.prototype.push = function (e, t) {\n  void 0 === t && (t = e), this.portals.push({\n    left: e,\n    right: t\n  });\n}, i.prototype.stringPull = function () {\n  var t,\n      n,\n      r,\n      o = this.portals,\n      i = [],\n      s = 0,\n      u = 0,\n      c = 0;\n  n = o[0].left, r = o[0].right, i.push(t = o[0].left);\n\n  for (var h = 1; h < o.length; h++) {\n    var a = o[h].left,\n        d = o[h].right;\n\n    if (e.triarea2(t, r, d) <= 0) {\n      if (!(e.vequal(t, r) || e.triarea2(t, n, d) > 0)) {\n        i.push(n), n = t = n, r = t, u = s = u, c = s, h = s;\n        continue;\n      }\n\n      r = d, c = h;\n    }\n\n    if (e.triarea2(t, n, a) >= 0) {\n      if (!(e.vequal(t, n) || e.triarea2(t, r, a) < 0)) {\n        i.push(r), n = t = r, r = t, u = s = c, c = s, h = s;\n        continue;\n      }\n\n      n = a, u = h;\n    }\n  }\n\n  return 0 !== i.length && e.vequal(i[i.length - 1], o[o.length - 1].left) || i.push(o[o.length - 1].left), this.path = i, i;\n};\n\nvar s,\n    u,\n    c,\n    h,\n    a,\n    d,\n    f = function f() {\n  this.zones = {};\n};\n\nf.createZone = function (e) {\n  return o.buildZone(e);\n}, f.prototype.setZoneData = function (e, t) {\n  this.zones[e] = t;\n}, f.prototype.getGroup = function (t, n) {\n  if (!this.zones[t]) return null;\n  var r = null,\n      o = Math.pow(50, 2);\n  return this.zones[t].groups.forEach(function (t, i) {\n    t.forEach(function (t) {\n      var s = e.distanceToSquared(t.centroid, n);\n      s < o && (r = i, o = s);\n    });\n  }), r;\n}, f.prototype.getRandomNode = function (t, n, r, o) {\n  if (!this.zones[t]) return new THREE.Vector3();\n  r = r || null, o = o || 0;\n  var i = [];\n  return this.zones[t].groups[n].forEach(function (t) {\n    r && o ? e.distanceToSquared(r, t.centroid) < o * o && i.push(t.centroid) : i.push(t.centroid);\n  }), e.sample(i) || new THREE.Vector3();\n}, f.prototype.getClosestNode = function (t, n, r, o) {\n  void 0 === o && (o = !1);\n  var i = this.zones[n].vertices,\n      s = null,\n      u = Infinity;\n  return this.zones[n].groups[r].forEach(function (n) {\n    var r = e.distanceToSquared(n.centroid, t);\n    r < u && (!o || e.isVectorInPolygon(t, n, i)) && (s = n, u = r);\n  }), s;\n}, f.prototype.findPath = function (e, t, r, o) {\n  var s = this.zones[r].groups[o],\n      u = this.zones[r].vertices,\n      c = this.getClosestNode(e, r, o),\n      h = this.getClosestNode(t, r, o, !0);\n  if (!c || !h) return null;\n\n  var a = n.search(s, c, h),\n      d = function d(e, t) {\n    for (var n = 0; n < e.neighbours.length; n++) {\n      if (e.neighbours[n] === t.id) return e.portals[n];\n    }\n  },\n      f = new i();\n\n  f.push(e);\n\n  for (var l = 0; l < a.length; l++) {\n    var v = a[l + 1];\n\n    if (v) {\n      var p = d(a[l], v);\n      f.push(u[p[0]], u[p[1]]);\n    }\n  }\n\n  f.push(t), f.stringPull();\n  var g = f.path.map(function (e) {\n    return new THREE.Vector3(e.x, e.y, e.z);\n  });\n  return g.shift(), g;\n}, f.prototype.clampStep = (c = new THREE.Vector3(), h = new THREE.Plane(), a = new THREE.Triangle(), d = new THREE.Vector3(), function (e, t, n, r, o, i) {\n  var f = this.zones[r].vertices,\n      l = this.zones[r].groups[o],\n      v = [n],\n      p = {};\n  p[n.id] = 0, s = void 0, d.set(0, 0, 0), u = Infinity, h.setFromCoplanarPoints(f[n.vertexIds[0]], f[n.vertexIds[1]], f[n.vertexIds[2]]), h.projectPoint(t, c), t.copy(c);\n\n  for (var g = v.pop(); g; g = v.pop()) {\n    a.set(f[g.vertexIds[0]], f[g.vertexIds[1]], f[g.vertexIds[2]]), a.closestPointToPoint(t, c), c.distanceToSquared(t) < u && (s = g, d.copy(c), u = c.distanceToSquared(t));\n    var x = p[g];\n    if (!(x > 2)) for (var I = 0; I < g.neighbours.length; I++) {\n      var b = l[g.neighbours[I]];\n      b.id in p || (v.push(b), p[b.id] = x + 1);\n    }\n  }\n\n  return i.copy(d), s;\n});\nexport { f as Pathfinding };","map":{"version":3,"mappings":"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","names":["Utils","computeCentroids","geometry","f","fl","face","faces","length","centroid","THREE","Vector3","add","vertices","a","b","c","divideScalar","e","roundNumber","value","decimals","Number","toFixed","sample","list","Math","floor","random","mergeVertexIds","aList","bList","sharedVertices","forEach","vID","indexOf","push","includes","shift","t","vId","clockwiseMostSharedVertex","counterClockwiseMostSharedVertex","cList","slice","temp","Error","pop","concat","setPolygonCentroid","polygon","navigationMesh","sum","vertexIds","copy","cleanPolygon","newVertexIds","i","nextVertexId","previousVertexId","previousVertex","vertex","s","clone","sub","angle","angleTo","PI","goodNeighbours","neighbours","neighbour","isConvex","convex","results","nextVertex","r","cross","y","distanceToSquared","dx","x","dy","dz","z","isPointInPoly","poly","pt","l","j","isVectorInPolygon","vector","lowestPoint","highestPoint","polygonVertices","min","max","this","triarea2","vequal","BinaryHeap","scoreFunction","content","element","sinkDown","result","end","bubbleUp","remove","node","const","size","rescoreElement","n","parentN","parent","elemScore","child2N","child1N","swap","child1Score","AStar","init","graph","let","g","h","cost","visited","closed","cleanUp","heap","search","start","openHeap","currentNode","curr","ret","reverse","il","gScore","beenVisited","heuristic","pos1","pos2","polygonId","Builder","buildZone","navMesh","_buildNavigationMesh","zone","v","groups","_buildPolygonGroups","findPolygonIndex","group","p","newGroup","map","portals","_getSharedVerticesInOrder","id","mergeVertices","_buildPolygonsFromGeometry","polygonGroups","groupCount","spreadGroupId","undefined","polygons","_buildPolygonNeighbours","vertexPolygonMap","neighbors","Set","groupA","get","groupB","groupC","candidate","has","Array","from","faceVertexUvs","Map","set","normal","sharedVerticesOrdered","Channel","p1","p2","stringPull","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","left","right","path","closestNode","closestDistance","point","plane","triangle","closestPoint","Pathfinding","zones","createZone","setZoneData","zoneID","getGroup","position","closestNodeGroup","distance","pow","index","measuredDistance","getRandomNode","groupID","nearPosition","nearRange","candidates","getClosestNode","checkPolygon","Infinity","findPath","startPosition","targetPosition","nodes","farthestNode","paths","getPortalFromTo","channel","nextPolygon","prototype","clampStep","Plane","Triangle","endTarget","nodeQueue","nodeDepth","setFromCoplanarPoints","projectPoint","closestPointToPoint","depth"],"sources":["../src/Utils.js","../src/BinaryHeap.js","../src/AStar.js","../src/Builder.js","../src/Channel.js","../src/index.js"],"sourcesContent":["class Utils {\n\n  static computeCentroids (geometry) {\n    var f, fl, face;\n\n    for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n      face = geometry.faces[ f ];\n      face.centroid = new THREE.Vector3( 0, 0, 0 );\n\n      face.centroid.add( geometry.vertices[ face.a ] );\n      face.centroid.add( geometry.vertices[ face.b ] );\n      face.centroid.add( geometry.vertices[ face.c ] );\n      face.centroid.divideScalar( 3 );\n\n    }\n  }\n\n  static roundNumber (value, decimals) {\n    return Number(value.toFixed(decimals));\n  }\n\n  static sample (list) {\n    return list[Math.floor(Math.random() * list.length)];\n  }\n\n  static mergeVertexIds (aList, bList) {\n\n    var sharedVertices = [];\n\n    aList.forEach((vID) => {\n      if (bList.indexOf(vID) >= 0) {\n        sharedVertices.push(vID);\n      }\n    });\n\n    if (sharedVertices.length < 2) return [];\n\n    if (sharedVertices.includes(aList[0]) && sharedVertices.includes(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.includes(bList[0]) && sharedVertices.includes(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    sharedVertices = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.push(vId);\n      }\n    });\n\n    var clockwiseMostSharedVertex = sharedVertices[1];\n    var counterClockwiseMostSharedVertex = sharedVertices[0];\n\n\n    var cList = aList.slice();\n    while (cList[0] !== clockwiseMostSharedVertex) {\n      cList.push(cList.shift());\n    }\n\n    var c = 0;\n\n    var temp = bList.slice();\n    while (temp[0] !== counterClockwiseMostSharedVertex) {\n      temp.push(temp.shift());\n\n      if (c++ > 10) throw new Error('Unexpected state');\n    }\n\n    // Shave\n    temp.shift();\n    temp.pop();\n\n    cList = cList.concat(temp);\n\n    return cList;\n  }\n\n  static setPolygonCentroid (polygon, navigationMesh) {\n    var sum = new THREE.Vector3();\n\n    var vertices = navigationMesh.vertices;\n\n    polygon.vertexIds.forEach((vId) => {\n      sum.add(vertices[vId]);\n    });\n\n    sum.divideScalar(polygon.vertexIds.length);\n\n    polygon.centroid.copy(sum);\n  }\n\n  static cleanPolygon (polygon, navigationMesh) {\n\n    var newVertexIds = [];\n\n    var vertices = navigationMesh.vertices;\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertexId, previousVertexId;\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertexId = polygon.vertexIds[1];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 1];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertexId = polygon.vertexIds[0];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 2];\n      } else {\n        nextVertexId = polygon.vertexIds[i + 1];\n        previousVertexId = polygon.vertexIds[i - 1];\n      }\n\n      nextVertex = vertices[nextVertexId];\n      previousVertex = vertices[previousVertexId];\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n\n      if (angle > Math.PI - 0.01 && angle < Math.PI + 0.01) {\n\n        // Remove the neighbours who had this vertex\n        var goodNeighbours = [];\n        polygon.neighbours.forEach((neighbour) => {\n          if (!neighbour.vertexIds.includes(polygon.vertexIds[i])) {\n            goodNeighbours.push(neighbour);\n          }\n        });\n        polygon.neighbours = goodNeighbours;\n\n\n        // TODO cleanup the list of vertices and rebuild vertexIds for all polygons\n      } else {\n        newVertexIds.push(polygon.vertexIds[i]);\n      }\n\n    }\n\n    polygon.vertexIds = newVertexIds;\n\n    this.setPolygonCentroid(polygon, navigationMesh);\n\n  }\n\n  static isConvex (polygon, navigationMesh) {\n\n    var vertices = navigationMesh.vertices;\n\n    if (polygon.vertexIds.length < 3) return false;\n\n    var convex = true;\n\n    var total = 0;\n\n    var results = [];\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertex = vertices[polygon.vertexIds[1]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 1]];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertex = vertices[polygon.vertexIds[0]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 2]];\n      } else {\n        nextVertex = vertices[polygon.vertexIds[i + 1]];\n        previousVertex = vertices[polygon.vertexIds[i - 1]];\n      }\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n      total += angle;\n\n      if (angle === Math.PI || angle === 0) return false;\n\n      var r = a.cross(b).y;\n      results.push(r);\n    }\n\n    // if ( total > (polygon.vertexIds.length-2)*Math.PI ) return false;\n\n    results.forEach((r) => {\n      if (r === 0) convex = false;\n    });\n\n    if (results[0] > 0) {\n      results.forEach((r) => {\n        if (r < 0) convex = false;\n      });\n    } else {\n      results.forEach((r) => {\n        if (r > 0) convex = false;\n      });\n    }\n\n    return convex;\n  }\n\n  static distanceToSquared (a, b) {\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    var dz = a.z - b.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  }\n\n  //+ Jonas Raoni Soares Silva\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static isPointInPoly (poly, pt) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\n    return c;\n  }\n\n  static isVectorInPolygon (vector, polygon, vertices) {\n\n    // reference point will be the centroid of the polygon\n    // We need to rotate the vector as well as all the points which the polygon uses\n\n    var lowestPoint = 100000;\n    var highestPoint = -100000;\n\n    var polygonVertices = [];\n\n    polygon.vertexIds.forEach((vId) => {\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\n      polygonVertices.push(vertices[vId]);\n    });\n\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\n      this.isPointInPoly(polygonVertices, vector)) {\n      return true;\n    }\n    return false;\n  }\n\n  static triarea2 (a, b, c) {\n    var ax = b.x - a.x;\n    var az = b.z - a.z;\n    var bx = c.x - a.x;\n    var bz = c.z - a.z;\n    return bx * az - ax * bz;\n  }\n\n  static vequal (a, b) {\n    return this.distanceToSquared(a, b) < 0.00001;\n  }\n}\n\nexport { Utils };\n","// javascript-astar\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a binary heap.\n\nclass BinaryHeap {\n  constructor (scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop () {\n    // Store the first element so we can return it later.\n    const result = this.content[0];\n    // Get the element at the end of the array.\n    const end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove (node) {\n    const i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    const end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size () {\n    return this.content.length;\n  }\n\n  rescoreElement (node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown (n) {\n    // Fetch the element that has to be sunk.\n    const element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = ((n + 1) >> 1) - 1;\n      const parent = this.content[parentN];\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        // Swap the elements if the parent is greater.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to sink any further.\n        break;\n      }\n    }\n  }\n\n  bubbleUp (n) {\n    // Look up the target element and its score.\n    const length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      let swap = null;\n      let child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n\n}\n\nexport { BinaryHeap };\n","import { BinaryHeap } from './BinaryHeap';\nimport { Utils } from './Utils.js';\n\nclass AStar {\n  static init (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      //for(var x in graph) {\n      const node = graph[x];\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.cost = 1.0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n    }\n  }\n\n  static cleanUp (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      const node = graph[x];\n      delete node.f;\n      delete node.g;\n      delete node.h;\n      delete node.cost;\n      delete node.visited;\n      delete node.closed;\n      delete node.parent;\n    }\n  }\n\n  static heap () {\n    return new BinaryHeap(function (node) {\n      return node.f;\n    });\n  }\n\n  static search (graph, start, end) {\n    this.init(graph);\n    //heuristic = heuristic || astar.manhattan;\n\n\n    const openHeap = this.heap();\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      const currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        let curr = currentNode;\n        const ret = [];\n        while (curr.parent) {\n          ret.push(curr);\n          curr = curr.parent;\n        }\n        this.cleanUp(ret);\n        return ret.reverse();\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\n      currentNode.closed = true;\n\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\n      const neighbours = this.neighbours(graph, currentNode);\n\n      for (let i = 0, il = neighbours.length; i < il; i++) {\n        const neighbour = neighbours[i];\n\n        if (neighbour.closed) {\n          // Not a valid node to process, skip to next neighbour.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\n        const gScore = currentNode.g + neighbour.cost;\n        const beenVisited = neighbour.visited;\n\n        if (!beenVisited || gScore < neighbour.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbour.visited = true;\n          neighbour.parent = currentNode;\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\n          neighbour.g = gScore;\n          neighbour.f = neighbour.g + neighbour.h;\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbour);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbour);\n          }\n        }\n      }\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  }\n\n  static heuristic (pos1, pos2) {\n    return Utils.distanceToSquared(pos1, pos2);\n  }\n\n  static neighbours (graph, node) {\n    const ret = [];\n\n    for (let e = 0; e < node.neighbours.length; e++) {\n      ret.push(graph[node.neighbours[e]]);\n    }\n\n    return ret;\n  }\n}\n\nexport { AStar };\n","import { Utils } from './Utils';\n\nlet polygonId = 1;\n\nclass Builder {\n  /**\n   * Constructs groups from the given navigation mesh.\n   * @param  {THREE.Geometry} geometry\n   * @return {Zone}\n   */\n  static buildZone (geometry) {\n\n    const navMesh = this._buildNavigationMesh(geometry);\n\n    const zone = {};\n\n    navMesh.vertices.forEach((v) => {\n      v.x = Utils.roundNumber(v.x, 2);\n      v.y = Utils.roundNumber(v.y, 2);\n      v.z = Utils.roundNumber(v.z, 2);\n    });\n\n    zone.vertices = navMesh.vertices;\n\n    const groups = this._buildPolygonGroups(navMesh);\n\n    zone.groups = [];\n\n    const findPolygonIndex = function (group, p) {\n      for (let i = 0; i < group.length; i++) {\n        if (p === group[i]) return i;\n      }\n    };\n\n    // TODO: This block represents 50-60% of navigation mesh construction time,\n    // and could probably be optimized. For example, construct portals while\n    // determining the neighbor graph.\n    groups.forEach((group) => {\n\n      const newGroup = [];\n\n      group.forEach((p) => {\n\n        // TODO: Optimize.\n        const neighbours = p.neighbours.map((n) => findPolygonIndex(group, n));\n\n        // Build a portal list to each neighbour\n        const portals = p.neighbours.map((n) => this._getSharedVerticesInOrder(p, n));\n\n        p.centroid.x = Utils.roundNumber(p.centroid.x, 2);\n        p.centroid.y = Utils.roundNumber(p.centroid.y, 2);\n        p.centroid.z = Utils.roundNumber(p.centroid.z, 2);\n\n        newGroup.push({\n          id: findPolygonIndex(group, p),\n          neighbours: neighbours,\n          vertexIds: p.vertexIds,\n          centroid: p.centroid,\n          portals: portals\n        });\n\n      });\n\n      zone.groups.push(newGroup);\n    });\n\n    return zone;\n  }\n\n  /**\n   * Constructs a navigation mesh from the given geometry.\n   * @param {THREE.Geometry} geometry\n   * @return {Object}\n   */\n  static _buildNavigationMesh (geometry) {\n    Utils.computeCentroids(geometry);\n    geometry.mergeVertices();\n    return this._buildPolygonsFromGeometry(geometry);\n  }\n\n  static _buildPolygonGroups (navigationMesh) {\n\n    const polygons = navigationMesh.polygons;\n\n    const polygonGroups = [];\n    let groupCount = 0;\n\n    const spreadGroupId = function (polygon) {\n      polygon.neighbours.forEach((neighbour) => {\n        if (neighbour.group === undefined) {\n          neighbour.group = polygon.group;\n          spreadGroupId(neighbour);\n        }\n      });\n    };\n\n    polygons.forEach((polygon) => {\n\n      if (polygon.group === undefined) {\n        polygon.group = groupCount++;\n        // Spread it\n        spreadGroupId(polygon);\n      }\n\n      if (!polygonGroups[polygon.group]) polygonGroups[polygon.group] = [];\n\n      polygonGroups[polygon.group].push(polygon);\n    });\n\n    return polygonGroups;\n  }\n\n  static _buildPolygonNeighbours (polygon, navigationMesh, vertexPolygonMap) {\n    const neighbors = new Set();\n\n    const groupA = vertexPolygonMap.get(polygon.vertexIds[0]);\n    const groupB = vertexPolygonMap.get(polygon.vertexIds[1]);\n    const groupC = vertexPolygonMap.get(polygon.vertexIds[2]);\n\n    // It's only necessary to iterate groups A and B. Polygons contained only\n    // in group C cannot share a >1 vertex with this polygon.\n    // IMPORTANT: Bubl cannot compile for-of loops.\n    groupA.forEach((candidate) => {\n      if (groupB.has(candidate) || groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n    groupB.forEach((candidate) => {\n      if (groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n\n    polygon.neighbours = Array.from(neighbors);\n  }\n\n  static _buildPolygonsFromGeometry (geometry) {\n\n    const polygons = [];\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n\n    // Constructing the neighbor graph brute force is O(n). To avoid that,\n    // create a map from vertices to the polygons that contain them, and use it\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\n    // is related to connectivity of the mesh.\n    const vertexPolygonMap = new Map(); // Map<vertexID, Set<polygonIndex>>\n    for (let i = 0; i < vertices.length; i++) {\n      vertexPolygonMap.set(i, new Set());\n    }\n\n    // Convert the faces into a custom format that supports more than 3 vertices\n    geometry.faces.forEach((face) => {\n      polygons.push({\n        id: polygonId++,\n        vertexIds: [face.a, face.b, face.c],\n        centroid: face.centroid,\n        normal: face.normal,\n        neighbours: []\n      });\n      vertexPolygonMap.get(face.a).add(polygons.length - 1);\n      vertexPolygonMap.get(face.b).add(polygons.length - 1);\n      vertexPolygonMap.get(face.c).add(polygons.length - 1);\n    });\n\n    const navigationMesh = {\n      polygons: polygons,\n      vertices: vertices,\n      faceVertexUvs: faceVertexUvs\n    };\n\n    // Build a list of adjacent polygons\n    polygons.forEach((polygon) => {\n      this._buildPolygonNeighbours(polygon, navigationMesh, vertexPolygonMap);\n    });\n\n    return navigationMesh;\n  }\n\n  static _getSharedVerticesInOrder (a, b) {\n\n    const aList = a.vertexIds;\n    const bList = b.vertexIds;\n\n    const sharedVertices = new Set();\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.add(vId);\n      }\n    });\n\n    if (sharedVertices.size < 2) return [];\n\n    if (sharedVertices.has(aList[0]) && sharedVertices.has(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.has(bList[0]) && sharedVertices.has(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    const sharedVerticesOrdered = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVerticesOrdered.push(vId);\n      }\n    });\n\n    return sharedVerticesOrdered;\n  }\n}\n\nexport { Builder };\n","import { Utils } from './Utils';\n\nclass Channel {\n  constructor () {\n    this.portals = [];\n  }\n\n  push (p1, p2) {\n    if (p2 === undefined) p2 = p1;\n    this.portals.push({\n      left: p1,\n      right: p2\n    });\n  }\n\n  stringPull () {\n    const portals = this.portals;\n    const pts = [];\n    // Init scan state\n    let portalApex, portalLeft, portalRight;\n    let apexIndex = 0,\n      leftIndex = 0,\n      rightIndex = 0;\n\n    portalApex = portals[0].left;\n    portalLeft = portals[0].left;\n    portalRight = portals[0].right;\n\n    // Add start point.\n    pts.push(portalApex);\n\n    for (let i = 1; i < portals.length; i++) {\n      const left = portals[i].left;\n      const right = portals[i].right;\n\n      // Update right vertex.\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\n          // Tighten the funnel.\n          portalRight = right;\n          rightIndex = i;\n        } else {\n          // Right over left, insert left to path and restart scan from portal left point.\n          pts.push(portalLeft);\n          // Make current left the new apex.\n          portalApex = portalLeft;\n          apexIndex = leftIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n\n      // Update left vertex.\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\n          // Tighten the funnel.\n          portalLeft = left;\n          leftIndex = i;\n        } else {\n          // Left over right, insert right to path and restart scan from portal right point.\n          pts.push(portalRight);\n          // Make current right the new apex.\n          portalApex = portalRight;\n          apexIndex = rightIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n    }\n\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\n      // Append last point to path.\n      pts.push(portals[portals.length - 1].left);\n    }\n\n    this.path = pts;\n    return pts;\n  }\n}\n\nexport { Channel };\n","/* global THREE */\n\nimport { Utils } from './Utils';\nimport { AStar } from './AStar';\nimport { Builder } from './Builder';\nimport { Channel } from './Channel';\n\n/**\n * Defines an instance of the pathfinding module, with one or more zones.\n */\nclass Pathfinding {\n\tconstructor () {\n\t\tthis.zones = {};\n\t}\n\n\t/**\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\n\t * @param  {THREE.Geometry} geometry\n\t * @return {Zone}\n\t */\n\tstatic createZone (geometry) {\n\t\treturn Builder.buildZone(geometry);\n\t}\n\n\t/**\n\t * Sets data for the given zone.\n\t * @param {string} zoneID\n\t * @param {Zone} zone\n\t */\n\tsetZoneData (zoneID, zone) {\n\t\tthis.zones[zoneID] = zone;\n\t}\n\n\t/**\n\t * Returns closest node group ID for given position.\n\t * @param  {string} zoneID\n\t * @param  {THREE.Vector3} position\n\t * @return {number}\n\t */\n\tgetGroup (zoneID, position) {\n\t\tif (!this.zones[zoneID]) return null;\n\n\t\tlet closestNodeGroup = null;\n\t\tlet distance = Math.pow(50, 2);\n\n\t\tthis.zones[zoneID].groups.forEach((group, index) => {\n\t\t\tgroup.forEach((node) => {\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\n\t\t\t\tif (measuredDistance < distance) {\n\t\t\t\t\tclosestNodeGroup = index;\n\t\t\t\t\tdistance = measuredDistance;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn closestNodeGroup;\n\t}\n\n\t/**\n\t * Returns a random node within a given range of a given position.\n\t * @param  {string} zoneID\n\t * @param  {number} groupID\n\t * @param  {THREE.Vector3} nearPosition\n\t * @param  {number} nearRange\n\t * @return {Node}\n\t */\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\n\n\t\tif (!this.zones[zoneID]) return new THREE.Vector3();\n\n\t\tnearPosition = nearPosition || null;\n\t\tnearRange = nearRange || 0;\n\n\t\tconst candidates = [];\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\n\n\t\tpolygons.forEach((p) => {\n\t\t\tif (nearPosition && nearRange) {\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\n\t\t\t\t\tcandidates.push(p.centroid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidates.push(p.centroid);\n\t\t\t}\n\t\t});\n\n\t\treturn Utils.sample(candidates) || new THREE.Vector3();\n\t}\n\n\t/**\n\t * Returns the closest node to the target position.\n\t * @param  {THREE.Vector3} position\n\t * @param  {string}  zoneID\n\t * @param  {number}  groupID\n\t * @param  {boolean} checkPolygon\n\t * @return {Node}\n\t */\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tlet closestNode = null;\n\t\tlet closestDistance = Infinity;\n\n\t\tnodes.forEach((node) => {\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\n\t\t\tif (distance < closestDistance\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\n\t\t\t\tclosestNode = node;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closestNode;\n\t}\n\n\t/**\n\t * Returns a path between given start and end points. If a complete path\n\t * cannot be found, will return the nearest endpoint available.\n\t *\n\t * @param  {THREE.Vector3} startPosition Start position.\n\t * @param  {THREE.Vector3} targetPosition Destination.\n\t * @param  {string} zoneID ID of current zone.\n\t * @param  {number} groupID Current group ID.\n\t * @return {Array<THREE.Vector3>} Array of points defining the path.\n\t */\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\n\t\tconst closestNode = this.getClosestNode(startPosition, zoneID, groupID);\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\n\n\t\t// If we can't find any node, just go straight to the target\n\t\tif (!closestNode || !farthestNode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\n\n\t\tconst getPortalFromTo = function (a, b) {\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\n\t\t\t\tif (a.neighbours[i] === b.id) {\n\t\t\t\t\treturn a.portals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We have the corridor, now pull the rope.\n\t\tconst channel = new Channel();\n\t\tchannel.push(startPosition);\n\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\tconst polygon = paths[i];\n\t\t\tconst nextPolygon = paths[i + 1];\n\n\t\t\tif (nextPolygon) {\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\n\t\t\t\tchannel.push(\n\t\t\t\t\tvertices[portals[0]],\n\t\t\t\t\tvertices[portals[1]]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchannel.push(targetPosition);\n\t\tchannel.stringPull();\n\n\t\t// Return the path, omitting first position (which is already known).\n\t\tconst path = channel.path.map((c) => new THREE.Vector3(c.x, c.y, c.z));\n\t\tpath.shift();\n\t\treturn path;\n\t}\n}\n\n/**\n * Clamps a step along the navmesh, given start and desired endpoint. May be\n * used to constrain first-person / WASD controls.\n *\n * @param  {THREE.Vector3} start\n * @param  {THREE.Vector3} end Desired endpoint.\n * @param  {Node} node\n * @param  {string} zoneID\n * @param  {number} groupID\n * @param  {THREE.Vector3} endTarget Updated endpoint.\n * @return {Node} Updated node.\n */\nPathfinding.prototype.clampStep = (function () {\n\tconst point = new THREE.Vector3();\n\tconst plane = new THREE.Plane();\n\tconst triangle = new THREE.Triangle();\n\n\tlet closestNode;\n\tlet closestPoint = new THREE.Vector3();\n\tlet closestDistance;\n\n\treturn function (start, end, node, zoneID, groupID, endTarget) {\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\n\t\tconst nodeQueue = [node];\n\t\tconst nodeDepth = {};\n\t\tnodeDepth[node.id] = 0;\n\n\t\tclosestNode = undefined;\n\t\tclosestPoint.set(0, 0, 0);\n\t\tclosestDistance = Infinity;\n\n\t\t// Project the step along the current node.\n\t\tplane.setFromCoplanarPoints(\n\t\t\tvertices[node.vertexIds[0]],\n\t\t\tvertices[node.vertexIds[1]],\n\t\t\tvertices[node.vertexIds[2]]\n\t\t);\n\t\tplane.projectPoint(end, point);\n\t\tend.copy(point);\n\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\n\n\t\t\ttriangle.set(\n\t\t\t\tvertices[currentNode.vertexIds[0]],\n\t\t\t\tvertices[currentNode.vertexIds[1]],\n\t\t\t\tvertices[currentNode.vertexIds[2]]\n\t\t\t);\n\n\t\t\ttriangle.closestPointToPoint(end, point);\n\n\t\t\tif (point.distanceToSquared(end) < closestDistance) {\n\t\t\t\tclosestNode = currentNode;\n\t\t\t\tclosestPoint.copy(point);\n\t\t\t\tclosestDistance = point.distanceToSquared(end);\n\t\t\t}\n\n\t\t\tconst depth = nodeDepth[currentNode];\n\t\t\tif (depth > 2) continue;\n\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\n\n\t\t\t\tnodeQueue.push(neighbour);\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\n\t\t\t}\n\t\t}\n\n\t\tendTarget.copy(closestPoint);\n\t\treturn closestNode;\n\t};\n}());\n\n/**\n * Defines a zone of interconnected groups on a navigation mesh.\n *\n * @type {Object}\n * @property {Array<Group>} groups\n * @property {Array<THREE.Vector3} vertices\n */\nconst Zone = {}; // jshint ignore:line\n\n/**\n * Defines a group within a navigation mesh.\n *\n * @type {Object}\n */\nconst Group = {}; // jshint ignore:line\n\n/**\n * Defines a node (or polygon) within a group.\n *\n * @type {Object}\n * @property {number} id\n * @property {Array<number>} neighbours IDs of neighboring nodes.\n * @property {Array<number} vertexIds\n * @property {THREE.Vector3} centroid\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\n * @property {boolean} closed\n * @property {number} cost\n */\nconst Node = {}; // jshint ignore:line\n\nexport { Pathfinding };\n"]},"metadata":{},"sourceType":"module"}