{"ast":null,"code":"/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    objects: {\n      default: ''\n    },\n    state: {\n      default: 'collided'\n    },\n    radius: {\n      default: 0.05\n    },\n    watch: {\n      default: true\n    }\n  },\n  init: function init() {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n\n    this.collisions = [];\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n  remove: function remove() {\n    this.pause();\n  },\n  play: function play() {\n    var sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {\n        childList: true,\n        subtree: true\n      });\n    }\n  },\n  pause: function pause() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function update() {\n    var data = this.data;\n    var objectEls; // Push entities into list of els to intersect.\n\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    } // Convert from NodeList to Array\n\n\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n  tick: function () {\n    var position = new THREE.Vector3(),\n        meshPosition = new THREE.Vector3(),\n        colliderScale = new THREE.Vector3(),\n        size = new THREE.Vector3(),\n        box = new THREE.Box3(),\n        distanceMap = new Map();\n    return function () {\n      var el = this.el,\n          data = this.data,\n          mesh = el.getObject3D('mesh'),\n          collisions = [];\n      var colliderRadius;\n\n      if (!mesh) {\n        return;\n      }\n\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale); // Update collision list.\n\n      this.els.forEach(intersect); // Emit events and add collision states, in order of distance.\n\n      collisions.sort(function (a, b) {\n        return distanceMap.get(a) > distanceMap.get(b) ? 1 : -1;\n      }).forEach(this.handleHit); // Remove collision state from current element.\n\n      if (collisions.length === 0) {\n        el.emit('hit', {\n          el: null\n        });\n      } // Remove collision state from other elements.\n\n\n      this.collisions.filter(function (el) {\n        return !distanceMap.has(el);\n      }).forEach(this.handleHitEnd); // Store new collisions\n\n      this.collisions = collisions; // Bounding sphere collision detection\n\n      function intersect(el) {\n        var radius, mesh, distance, extent;\n\n        if (!el.isEntity) {\n          return;\n        }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) {\n          return;\n        }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) {\n          return;\n        }\n\n        distance = position.distanceTo(meshPosition);\n\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      } // use max of scale factors to maintain bounding sphere collision\n\n\n      function scaleFactor(scaleVec) {\n        return Math.max.apply(null, scaleVec.toArray());\n      }\n    };\n  }(),\n  handleHit: function handleHit(targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.el.emit('hit', {\n      el: targetEl\n    });\n  },\n  handleHitEnd: function handleHitEnd(targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.el.emit('hitend', {\n      el: targetEl\n    });\n  }\n});","map":{"version":3,"names":["module","exports","AFRAME","registerComponent","schema","objects","default","state","radius","watch","init","observer","els","collisions","handleHit","bind","handleHitEnd","remove","pause","play","sceneEl","el","data","MutationObserver","update","observe","childList","subtree","disconnect","objectEls","querySelectorAll","children","Array","prototype","slice","call","tick","position","THREE","Vector3","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","mesh","getObject3D","colliderRadius","clear","object3D","getWorldPosition","getWorldScale","scaleFactor","forEach","intersect","sort","a","b","get","length","emit","filter","has","distance","extent","isEntity","setFromObject","getSize","Math","max","x","y","z","sqrt","getCenter","distanceTo","push","set","scaleVec","apply","toArray","targetEl","addState","removeState"],"sources":["X:/Project/graph/node_modules/aframe-extras/src/misc/sphere-collider.js"],"sourcesContent":["/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    objects: {default: ''},\n    state: {default: 'collided'},\n    radius: {default: 0.05},\n    watch: {default: true}\n  },\n\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n\n  remove: function () {\n    this.pause();\n  },\n\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\n    }\n  },\n\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n\n  tick: (function () {\n    const position = new THREE.Vector3(),\n        meshPosition = new THREE.Vector3(),\n        colliderScale = new THREE.Vector3(),\n        size = new THREE.Vector3(),\n        box = new THREE.Box3(),\n        distanceMap = new Map();\n    return function () {\n      const el = this.el,\n          data = this.data,\n          mesh = el.getObject3D('mesh'),\n          collisions = [];\n      let colliderRadius;\n\n      if (!mesh) { return; }\n\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\n        .forEach(this.handleHit);\n\n      // Remove collision state from current element.\n      if (collisions.length === 0) { el.emit('hit', {el: null}); }\n\n      // Remove collision state from other elements.\n      this.collisions\n        .filter((el) => !distanceMap.has(el))\n        .forEach(this.handleHitEnd);\n\n      // Store new collisions\n      this.collisions = collisions;\n\n      // Bounding sphere collision detection\n      function intersect (el) {\n        let radius, mesh, distance, extent;\n\n        if (!el.isEntity) { return; }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) { return; }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) { return; }\n\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor (scaleVec) {\n        return Math.max.apply(null, scaleVec.toArray());\n      }\n    };\n  })(),\n\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.el.emit('hit', {el: targetEl});\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.el.emit('hitend', {el: targetEl});\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}